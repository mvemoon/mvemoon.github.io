{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/qrious.js","path":"js/qrious.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/catalog.png","path":"css/images/catalog.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/error_icon.png","path":"css/images/error_icon.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/escheres.png","path":"css/images/escheres.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/logo.png","path":"css/images/logo.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/menu.png","path":"css/images/menu.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/top.png","path":"css/images/top.png","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/vexo/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1627447000146},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1627447000146},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1627447000146},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1627447000146},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1627447000146},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1627447000150},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1627447000150},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1627447000150},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1627447000150},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1627447000150},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1627447000150},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1627447000150},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1627447000150},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1627447000150},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1627447000150},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1627447000150},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1627447000150},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1627447000150},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1627447000150},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1627447000150},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1627447000150},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1627447000150},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627447000150},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1627447000150},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1627447000150},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1627447000150},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1627447000150},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1627447000150},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1627447000150},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1627447000150},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1627447000150},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1627447000150},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1627447000154},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1627447000154},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1627447000154},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1627447000150},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1627447000154},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1627447000150},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1627447000154},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1627447000154},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1627447000154},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1627447000154},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1627447000154},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1627447000154},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1627447000154},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1627447000154},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1627447000154},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1627447000154},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1627447000154},{"_id":"public/2021/07/28/hello-world/index.html","hash":"8b9a4894791742bcc20db674402c492d2ac25ce3","modified":1629466586537},{"_id":"public/archives/2021/index.html","hash":"008b35e1cdf0570409ddb9488b90add656894cf8","modified":1629466916300},{"_id":"public/archives/index.html","hash":"5ecb046d2824c17e90b90f4cbbc4d43054a2c518","modified":1629466916300},{"_id":"public/archives/2021/07/index.html","hash":"59d4665d4321bfd7e6fb076908af92b16e4bd6ef","modified":1629466916300},{"_id":"public/index.html","hash":"ace236d5e675ecaf518002173bdac52b0c1a2227","modified":1629466916300},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1627474983557},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1627474983557},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1627474983557},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1627474983557},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1627474983557},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1627474983557},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1627474983557},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1627474983557},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1627474983557},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1627474983557},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1627474983557},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1627474983557},{"_id":"public/js/script.js","hash":"1e0a395deba4f5ae66a5758590e094d26d777421","modified":1627478149719},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1627474983557},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1627474983557},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1627474983557},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1627474983557},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1627474983557},{"_id":"public/css/style.css","hash":"5adfacca2813469f858b0916dbfdeaf7d0f083e9","modified":1627478149719},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1627474983557},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1627474983557},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1627474983557},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1627474983557},{"_id":"source/_posts/test.md","hash":"85a8b3e167ab786a2a4a825e110c0f4c09bc5021","modified":1627476052875},{"_id":"public/2021/07/28/test/index.html","hash":"8adc6251955149dc7f9d27873adda5fbf00a973a","modified":1627787316394},{"_id":"source/series/index.md","hash":"364b07ea1e0b28e792fc7bbddac0069c771dbefa","modified":1627478099732},{"_id":"source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1627478099732},{"_id":"source/tags/index.md","hash":"a79a6d1880b14fb2b87cc8932bccd64768a3d509","modified":1629443292843},{"_id":"source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1627478099732},{"_id":"themes/vexo/.gitignore","hash":"37fb9fd49e7f944716efd3284a6bf55adb6dd0c2","modified":1627477771162},{"_id":"themes/vexo/LICENSE","hash":"3e135cd69c0e02c0a49dd43d571f600223cc61d1","modified":1627477771162},{"_id":"themes/vexo/_config.yml","hash":"6d60a2ff2436a8d669cca200aaa25ad59cc967b1","modified":1627477771162},{"_id":"themes/vexo/.travis.yml","hash":"cc482f06f4ea6962058f2548dcb814b954876e76","modified":1627477771162},{"_id":"themes/vexo/README.md","hash":"76d30348cde696a75dd4f50b0747c5e8e3779046","modified":1627477771162},{"_id":"themes/vexo/lint.sh","hash":"f580302e4aa9ccfb95a253851da6501d145613fe","modified":1627477771162},{"_id":"themes/vexo/package.json","hash":"44e46ed458ca4351db2a773bb4c09ac814b7b1e0","modified":1627477771162},{"_id":"themes/vexo/layout/archive.ejs","hash":"f2480a73048bcb8673d78283090634d0857b80fb","modified":1627477771162},{"_id":"themes/vexo/layout/about.ejs","hash":"76ba7418788eb2bb9ba46844f4d750734847d0b4","modified":1627477771162},{"_id":"themes/vexo/layout/index.ejs","hash":"9f12f5928d68d4d68175b825e18f89f3b0dfdb69","modified":1627477771162},{"_id":"themes/vexo/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1627477771162},{"_id":"themes/vexo/layout/page.ejs","hash":"c5a6f2f18b0cf664c7a34945ff46f83c81d6924c","modified":1627477771162},{"_id":"themes/vexo/layout/project.ejs","hash":"a023b833a64006989c718c8d6125978a87fa2c3e","modified":1627477771162},{"_id":"themes/vexo/layout/series.ejs","hash":"32010111ef27d2eefec44aba5a865064659d613a","modified":1627477771162},{"_id":"themes/vexo/layout/tags.ejs","hash":"256413f3c6098eba42fce8f24319913e4b2512dc","modified":1627477771162},{"_id":"themes/vexo/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1627477771162},{"_id":"themes/vexo/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1627477771162},{"_id":"themes/vexo/_source/series/index.md","hash":"364b07ea1e0b28e792fc7bbddac0069c771dbefa","modified":1627477771162},{"_id":"themes/vexo/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/catalog.ejs","hash":"0352ce39c28074dcfc3bd6416680195eeb384fd1","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/footer.ejs","hash":"6cf6b5ddb1c4c2e219fdb56ef0ab5c984bb4e7e9","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/head.ejs","hash":"cbd8c09e3349ed4facec92d5068c4ee777d52418","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/header.ejs","hash":"8a3a4d5895330176e18bd6500b86b494c9246e7c","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/nav.ejs","hash":"3d8ddc1f6e135a240d40edd157cf37f5d0a12df6","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/pager.ejs","hash":"3a1b9680fbfa3baa76933c7c17216996381ad241","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1627477771162},{"_id":"themes/vexo/layout/_third-party/google_analytics.ejs","hash":"d09107a4ee5753a2fbbdb16ddf79d23ff0618c19","modified":1627477771162},{"_id":"themes/vexo/layout/_third-party/localsearch.ejs","hash":"fdf9e9f25b673c3f66694581cf5ebb578e5393b9","modified":1627477771162},{"_id":"themes/vexo/layout/_third-party/mathjax.ejs","hash":"aa58f0cfe22e7151c1a0521bbfa5cbd76f6dcd9d","modified":1627477771162},{"_id":"themes/vexo/source/css/_config.styl","hash":"0c9c0e77d6b8813cb76494e8d757843aab9e117b","modified":1627477771162},{"_id":"themes/vexo/source/css/style.styl","hash":"9dcd5509187654c29d0d908016a052fd164d257c","modified":1627477771166},{"_id":"themes/vexo/source/js/local-search.js","hash":"2d4c35e67f6ae2234a220c2898534d5bcb5245a2","modified":1627477771170},{"_id":"themes/vexo/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1627477771170},{"_id":"themes/vexo/source/js/script.js","hash":"1e0a395deba4f5ae66a5758590e094d26d777421","modified":1627477771170},{"_id":"themes/vexo/layout/_partial/search/localsearch_button.ejs","hash":"3cb21e8d581ee998796f3f4bf9cd00abb9a67072","modified":1627477771162},{"_id":"themes/vexo/layout/_partial/search/localsearch_view.ejs","hash":"79e5e1a159d18b9e05961a47a4607b14be447e50","modified":1627477771162},{"_id":"themes/vexo/source/css/_partial/about.styl","hash":"1fc9572052194d94f86224a860e6b52435492e57","modified":1627477771162},{"_id":"themes/vexo/source/css/_partial/archive.styl","hash":"e80ddf26f2af3523632afeabd57f81592537985a","modified":1627477771162},{"_id":"themes/vexo/source/css/_partial/catalog.styl","hash":"e3fd04eb0ae723def29592a0063e0706046cb6f2","modified":1627477771162},{"_id":"themes/vexo/source/css/_partial/categories.styl","hash":"d78cf86064428693e2173b4f23535cf311d18091","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/footer.styl","hash":"d90207a2b25e7a7a12b94cfcd5dde070422783e7","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/header.styl","hash":"6154d83977e8e725c52786b14a4d9b3bc62b1061","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/markdown.styl","hash":"2a1a99a0a8a9ffab1e64b7d7c9241ce8d5c84c39","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/nav.styl","hash":"e92c010c5cd460e75c67083df8cdd0bf4d25cde4","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/project.styl","hash":"e9b6faadf4852bce3a4141cba0a102a7afb81e9f","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/search.styl","hash":"4fa3d5c7efd1de510719157bd7a6ab3c9f24e9fd","modified":1627477771166},{"_id":"themes/vexo/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1627477771166},{"_id":"themes/vexo/source/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1627477771166},{"_id":"themes/vexo/source/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1627477771166},{"_id":"themes/vexo/source/css/images/error_icon.png","hash":"efec6e759508dd02e6fa8c4facd9a25a61aae055","modified":1627477771166},{"_id":"themes/vexo/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1627477771166},{"_id":"themes/vexo/source/css/images/logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1627477771166},{"_id":"themes/vexo/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1627477771166},{"_id":"themes/vexo/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1627477771166},{"_id":"themes/vexo/source/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1627477771166},{"_id":"themes/vexo/source/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1627477771166},{"_id":"themes/vexo/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1627477771166},{"_id":"themes/vexo/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1627477771170},{"_id":"public/series/index.html","hash":"505c516c37d4ec2db30124e6cdab3c0a3b4c6e54","modified":1629466916300},{"_id":"public/project/index.html","hash":"784202a64854bf7859269a70ec4a24fffb5078b6","modified":1629466916300},{"_id":"public/tags/index.html","hash":"724575e342ce2f5d7fb5141b0fdab3319336bf69","modified":1629466916300},{"_id":"public/about/index.html","hash":"82e48257c8215ec1189527049c71048acc0ecdc4","modified":1629466916300},{"_id":"public/css/images/catalog.png","hash":"541d20dd600fc2c9230329ceb6885d86e6c151dd","modified":1627478149719},{"_id":"public/css/images/alipay.jpg","hash":"c49822ea6f06f868c2404fb00a93f913c8fff7b5","modified":1627478149719},{"_id":"public/css/images/error_icon.png","hash":"efec6e759508dd02e6fa8c4facd9a25a61aae055","modified":1627478149719},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1627478149719},{"_id":"public/css/images/logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1627478149719},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1627478149719},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1627478149719},{"_id":"public/css/images/wechat.jpg","hash":"5bed6d3eb9f71b227b0ea0187c1a7ba8caf5ee64","modified":1627478149719},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1627478149719},{"_id":"public/js/local-search.js","hash":"2d4c35e67f6ae2234a220c2898534d5bcb5245a2","modified":1627478149719},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1627478149719},{"_id":"public/css/plugins/gitment.css","hash":"541ff18d7f3542b5663dc6aad06d43e135332b71","modified":1627478149719},{"_id":"public/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1627478149719},{"_id":"source/_posts/Bits-Intergers-Floating-Points.md","hash":"613575252d6f4dabce6396348f36a95048f000f4","modified":1627874099900},{"_id":"public/2021/07/28/Bits-Intergers-Floating-Points/index.html","hash":"a02fdddbd0c7af2f0e62a1247fcab1b7a758075c","modified":1629466586537},{"_id":"source/_posts/endian","hash":"b057ee3e6c773791cb34e48be1e40e345e4a15ee","modified":1627486699518},{"_id":"source/_posts/endian.c","hash":"991d1d12579f312c63302e6624f697f287d15125","modified":1627486697186},{"_id":"source/_posts/conver","hash":"10ee5b6abfee756ca1fb9fed58b6a365163a573e","modified":1627551474659},{"_id":"source/_posts/conver.c","hash":"3c4c13c11dcb52973409ffd9b6113bd9acca4177","modified":1627551495456},{"_id":"source/_posts/Machine-Level-Representation-of-Programs.md","hash":"bb54402c9282e5d45fda0169f2b2ad419c185366","modified":1627861973608},{"_id":"source/_posts/bag.md","hash":"e89fb74a393387484227fb9f687ae9482af5c9e7","modified":1627874073607},{"_id":"public/2021/08/01/Machine-Level-Representation-of-Programs/index.html","hash":"8911d9c71f3e4f6eb0f6404e5bb0b1298b5f9d0c","modified":1629466586537},{"_id":"public/2021/08/01/bag/index.html","hash":"5b764968a5145cb249cee3ff06df7ca3c47f29fa","modified":1627787316394},{"_id":"public/archives/2021/08/index.html","hash":"e8afb22a8a1c3f077cd03df17e3f3da3edfe6627","modified":1629466916300},{"_id":"source/_posts/.deep-learning-part-1.md.swp","hash":"2c3d5ccf8d56bcafb5ba1d380cb8b01ef618b8e3","modified":1628499859585},{"_id":"source/_posts/Exceptional-Control-Flow.md","hash":"474ee0dfb23cf81d246e0aa25a40a2a18705a607","modified":1629443137715},{"_id":"source/_posts/Concurrent-Programming.md","hash":"f8a7b1a129a0577dbf65c910251d6ead72828b97","modified":1628697420657},{"_id":"source/_posts/Network-Programming.md","hash":"65ff406c400684392864a64e7a7810591d3fd77c","modified":1627982660769},{"_id":"source/_posts/Pytorch-Dataloader.md","hash":"34b3173037ad85dc3628d0cd99995b57bbd0a00f","modified":1628604036588},{"_id":"source/_posts/deep-learning-part-1.md","hash":"e1e378d93342d59c21877ef0c1d2437de3f8b9f8","modified":1628494751306},{"_id":"source/_posts/Pytorch-Embedding.md","hash":"3508c2bf3900ef4a85f9ede5107fcbd8dec488a7","modified":1628563645240},{"_id":"source/_posts/System-Level-I-O.md","hash":"f44cd598e66a81e7b9358fbdc9fe42799ec6fee3","modified":1628648299194},{"_id":"source/_posts/surprise.md","hash":"34294885c9d0d9bb94d45c2960af83d5dd55bc34","modified":1628181628183},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1629442423966},{"_id":"themes/butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1629442423970},{"_id":"themes/butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1629442423970},{"_id":"themes/butterfly/package.json","hash":"c18b118422237b964063874a099945b79573feca","modified":1629442423974},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1629442423966},{"_id":"themes/butterfly/_config.yml","hash":"a5c991baa258761784c40764551a416f86470f60","modified":1629450478300},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1629442423970},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1629442423970},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1629442423970},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1629442423970},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1629442423970},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1629442423970},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1629442423974},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1629442423974},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1629442423974},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1629442423974},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1629442423966},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1629442423966},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1629442423966},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1629442423966},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1629442423970},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1629442423974},{"_id":"themes/butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1629442423974},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1629442423974},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1629442423974},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1629442423974},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1629442423974},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1629442423974},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1629442423974},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1629442423974},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1629442423974},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1629442423974},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1629442423978},{"_id":"themes/butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1629442423978},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1629442423978},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1629442423978},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1629442423978},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1629442423978},{"_id":"themes/butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1629442423978},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1629442423982},{"_id":"themes/butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1629442423982},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1629442423974},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":1629442423974},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1629442423974},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1629442423974},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"98235fcda3b87ad6f7e91eafbed94d0d6ae847ca","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1629442423978},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1629442423978},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1629442423978},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"97fec1e814f88237862f4d800a35362b802f6625","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1629442423978},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1629442423978},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1629442423978},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1629442423978},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1629442423978},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1629442423978},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1629442423978},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1629442423970},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"36f3c603d2a2ecddaa6d2675a89d76ad94968f72","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1629442423974},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1629442423974},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1629442423974},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1629442423978},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1629442423978},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1629442423978},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1629442423978},{"_id":"public/2021/08/10/Pytorch-Embedding/index.html","hash":"f8f942bd59cdd0267a974257678fd9615ab9bed8","modified":1629466586537},{"_id":"public/2021/08/10/Pytorch-Dataloader/index.html","hash":"81de7ae8de54b14767aa14de4ea1954de65e5b5b","modified":1629466586537},{"_id":"public/2021/08/06/surprise/index.html","hash":"6433a89cdce2231bd0bb10bd17e0aadc2cbee624","modified":1629466586537},{"_id":"public/2021/08/09/deep-learning-part-1/index.html","hash":"a693566165da1b27a73fd7d5a2cd9765c5125036","modified":1629466586537},{"_id":"public/2021/08/02/bag/index.html","hash":"cf5ce6427abe8824baaac3191d37b13fb81bc6ee","modified":1629466586537},{"_id":"public/2021/08/11/Exceptional-Control-Flow/index.html","hash":"dc8617690c26e7ff41ecc1af47a9fdb6684d6156","modified":1629466586537},{"_id":"public/2021/08/11/Concurrent-Programming/index.html","hash":"c133171c0a85699fdff9058b5428b3cc3db36e1c","modified":1629466586537},{"_id":"public/2021/08/10/System-Level-I-O/index.html","hash":"efee83f92745c5cbcdc1cccffdb54bbded1b9a70","modified":1629466586537},{"_id":"public/2021/08/02/Network-Programming/index.html","hash":"804b5c4b50dc8f60c517853198ea0f85c384a814","modified":1629466586537},{"_id":"public/archives/page/2/index.html","hash":"bede7c6b1251b8596c7f0515e8c6950854176b14","modified":1629466916300},{"_id":"public/archives/2021/page/2/index.html","hash":"eef0a04ecb4778b0e91a5feba04778c178de6755","modified":1629466916300},{"_id":"public/page/2/index.html","hash":"b207358f8c7d1f1766f9f04bd76e1bdaff643226","modified":1629466916300},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1629443147111},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1629443147111},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1629443147111},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1629443147111},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1629443147111},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1629443147111},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1629443147111},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1629443147111},{"_id":"public/css/index.css","hash":"4e5d9ead0952d31f549bbc22765a615a4540f58b","modified":1629443147111},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1629443147111},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1629443147111},{"_id":"source/tags/index-1.md","hash":"1ec061485a8832db0cfcab2ba28f04cbceed10b4","modified":1629443245054},{"_id":"public/tags/index-1.html","hash":"76bae56aa4a34634f03748b309a5e3d889d3e223","modified":1629466916300},{"_id":"source/categories/index.md","hash":"e7e4d88cfeeb37a9138654560f8f0f96b16a5e45","modified":1629443400617},{"_id":"source/link/index.md","hash":"825b112bdcb75221d1aa7e37dbc97930fbac4bc0","modified":1629443435090},{"_id":"public/categories/index.html","hash":"4b63817530b1c9144ed99b476e3418bcd6a579a5","modified":1629466916300},{"_id":"public/link/index.html","hash":"65b382447309bc2bb88b1a3eb1909f0d78db38c8","modified":1629466916300},{"_id":"themes/butterfly/._config.yml.swp","hash":"eebef90b2d360f83ac9e3496ed442e89028df373","modified":1629466669565}],"Category":[],"Data":[],"Page":[{"title":"Series","layout":"series","_content":"","source":"series/index.md","raw":"---\ntitle: Series\nlayout: series\n---\n","date":"2021-07-28T13:14:59.732Z","updated":"2021-07-28T13:14:59.732Z","path":"series/index.html","comments":1,"_id":"ckrnigxdt00003jkk0i789tj5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2021-07-28T13:14:59.732Z","updated":"2021-07-28T13:14:59.732Z","path":"project/index.html","comments":1,"_id":"ckrnigxdv00013jkk9hu87u6u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\ntype: \"tags\"\n---\n","date":"2021-08-20T07:08:12.851Z","updated":"2021-08-20T07:08:12.843Z","path":"tags/index.html","_id":"ckrnigxdw00023jkk9ywr76g0","comments":1,"content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"About","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---","date":"2021-07-28T13:14:59.732Z","updated":"2021-07-28T13:14:59.732Z","path":"about/index.html","comments":1,"_id":"ckrnigxdw00033jkk62bg5kjg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2021-08-20T07:07:25.000Z","_content":"","source":"tags/index-1.md","raw":"---\ntitle: tags\ndate: 2021-08-20 15:07:25\n---\n","updated":"2021-08-20T07:07:25.054Z","path":"tags/index-1.html","_id":"cksk0fqoq00002jkk3awuaa67","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"categories","date":"2021-08-20T07:09:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-08-20 15:09:36\ntype: \"categories\"\n---\n","updated":"2021-08-20T07:10:00.617Z","path":"categories/index.html","_id":"cksk0ijxd0000chkkh4bz48n6","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"link","date":"2021-08-20T07:10:16.000Z","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2021-08-20 15:10:16\n---\n","updated":"2021-08-20T07:10:16.270Z","path":"link/index.html","_id":"cksk0jemx0001chkk8pmgbxwm","comments":1,"layout":"page","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-07-28T04:36:40.146Z","updated":"2021-07-28T04:36:40.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrngl2cm00001okk5eqs7drl","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Bits & Intergers & Floating Points","date":"2021-07-28T14:01:50.000Z","mathjax":true,"_content":"\n# Bits & Interters & Floating Points\n\n## Bit\n计算机以二进制理解世界，也就是一串0和1，重要的是bit representation（二进制表示）以及 decoding（解读方式)。\n以文件的传输为例，ASCII文件中的文字首先被编码成二进制形式，然后发送给接收者，接收端以一定的规则解码得到原来的文件。\n```\n发送者 (encoding) ------> 01100110 (decoding)------> 接收者\n```\ndecoding方式带来的影响：\n```\n以4-bit的data type 为例\n1111 --       int     --> -1\n1111 --  unsigned int --> 15\n```\n由于 int 采用补码形式表示，而usigned不是导致值不同（后文详解）\n\n### Data Size\n1 bit 即是1个0或1，8 bits == 1 byte, 16 bits == 2 bytes == 1 words\nword size 就是指针所占的字位数\n\n### Address\n当我们谈到计算机的内存与地址时，一般指的是虚拟内存，每一bit都有它的地址\n### Byte Ordering\n既然bit都有自己的地址，那么连续的bits的地址一定是连续的，它们存储方式有两种big endian, little endian。\n```\naddress        0x100  0x101  0x102 0x103\nbig endian        01     23     45    67\nlittle endian     67     45     23    01\n```\nbig endian 即是大地址结尾，而little endian 即是以小地址结尾。\n在我的机子上，其以little endian方式存储，可以用以下的C代码验证\n```C\n#include <stdio.h>\n\nvoid show_bytes(char* c_p, size_t n)\n{i\n\t\tfor(size_t i = 0; i<n; i++)\n\t\t{\n\t\t\t\tprintf(\"%X \", *c_p);\n\t\t\t\tc_p++;\n\t\t}\n\t\tputs(\"\");\n}\n\nint main(void)\n{\n\tint m = 0x12345678;\n\tprintf(\"%X\\n\", m);\n\tshow_bytes((char*)(&m), sizeof(int));\n\t\n\treturn 0;\n}\n```\n\n```bash\n./endian\n12345678\n78 56 34 12  \n```\n\n了解大小端的意义如下：\n- 网络传输大多用big-endian, 而计算机一般用little-endian\n- 汇编、机器码的顺序\n- C中的cast操作，如union可能带来问题\n\n### String (ASCII)\n由于ASCII的范围0~127，每一次都读取一个byte，所以不受大小端的影响\n\n---\n\n## Intergers\n\n\n### Unsigned & Two's Complement\n\n假设有一个data的bit vector, [w<sub>k-1</sub>, w<sub>k-2</sub> .. w<sub>0</sub>], unsigned : 求和每一位的2的次幂乘以w<sub>x</sub>, Two's Complement ： 第一位为符号位，其拥有负权重2<sub>k-1</sup>。\n\n这也即当符号为为1时，其值为负而0为正的原因：最大的负数 -1 ： 2<sub>k-1</sup> + (2<sub>k-1</sup> -1)，同时记U至T的转换为U2T(x) = x<sub>t</sub> - w<sub>k-1</sub> * 2<sub>k</sup>\n\n---\n\n### Bit-Level Operations\n&（位与） |（位或）^(异或) >>（右移） <<(左移)\t~(取补码)\n```\n&  0 1       |  0 1     ^ 0 1    ~ 0 1\n0  0 0       0  0 1     0 0 1      \n1  0 1       1  1 1     1 1 0      1 0\n```\n\n#### 关于 &,&&　　|,|| \n当逻辑运算符&&，||操作的对象为一个bit时，相当于&, |\n\n#### 关于~\n**x　+　~x+1　=　0**　也即~x+1为x的加法逆元\n\n#### 关于 ^\n* 用于Floating Points符号位的计算较为方便（NaN除外）, 相当于求其加法逆元(Integers用~x+1方便)\n* x^x = 0\n\n####  左移　右移\n左移、右移顾名思义就是将bit vector向左、右移动，多出来的bit自然舍去，问题在于缺少的bit位是用0/1来补，而这在U/T的表现又不同\n\nU/T 左移 ： 用0补齐缺少位，称为逻辑左移\n\nU 右移 ： 用0补齐缺少位，称为逻辑右移\n\nT 右移 ： 补齐位与符号位一致，可以为0/1，称为算术右移\n　\n左移k位，所有对应位的权重都增大k,相当于乘以 2<sub>k</sup>  （int符号位虽然是负权重，但是结果相同）\n\n右移k位，所有对应位的权重都减少k,相当于除以 2<sub>k</sup> ,需要注意的是结果需要**Rounding**(取整)。C中的整数取整都是向0取整，而应用>>时正数：向下取整，也即向0取整，而对于负数来说，其依然是向下取整，所有需要加上相应的bias,使其满足向0取整。bias = 1 << k-1\n\n### Conversion\n转变分为三种\n- int 与 unsigned int\n- 小字节类型转大字节类型\n- 大字节类型转小字节类型\n\nint 与 unsigned int 的转换在C中并不改变其bit-represention,只是改变其解读形式。\n\n大字节转小字节则是要截断高位。\n\n小字节转大字节，则需要拓展高位，这其中又分为sign expansion && zero expansion。\n\n　　首先考虑U-U的小转大，采用零拓展，即高位全用0填补。\n　　T-T的拓展，采用符号拓展，即高位拓展取决与符号为。\n　　那么U-T,T-U的小字节转大字节是怎么实现的呢？规律是先变size再改变类型。也就是其拓展与改变前的拓展类型一致，举例如下：\n```C\n#include <stdio.h>\n\nint main(void)\n{\n\tunsigned short int s_u = 0xcfff;\n\tshort int s_t = 0xcfff;\n\tint i_u = (int)s_u;\n\tint i_t = (int)s_t;\n\tprintf(\"i_u : %x\\n\", i_u);\n\tprintf(\"i_t : %x\\n\", i_t);\n\treturn 0;\n}\n```\n```bash\ni_u : cfff\ni_t : ffffcfff\n```\n\n### Integers Arithmetic\n\n这些运算以及数据本身构成了群，如无整型与加法构成了无整型加群，在这里引入群中的一个概念，加法逆元，若a+b=0，则称b为a的逆元。\n\n#### Modular addition\n加法其实是Modualr addition,即对最后的结果取模。\n```C\n        U                    T\n\t x=0:    x          x=Tmin: Tmin \n-x                         \n\t x>0:   2**w - x    x>Tmin: -x\n\n\n溢出检测：\n     !(x + y < x)       !(x<0 && y<0 && sum >=0) && !(x>=0 && y>=0 && sum<0) (OR !((x<0 == y<0) && (sum<0 != x<0)))\n```\n加法逆元的C表达式：\n> ~x+1\n\n#### Muplication\nunsigned 计算时同样时将结果mod 2<sub>w</sub>, signed计算则是先将其转为unsigned计算，最后转回signed。这也同样表明了两种类型的乘法运算结果truncted后的bit-representation是一样的。\n\n溢出检测的两种方式：\n```C\n///1.群的性质\nint tmult_ok(int x, int y)\n{\n\tint p = x*y;\n\treturn !x || p/x == y;\n}\n\n///2.用更大的数位表示\nint tmult_ok(int x, int y)\n{\n\tin64_t pll = (in64_t)x*y;\n\treturn pll == (int)pll;\n}\n\n```\n> Tips : size_t被定义为unsigned类型，而malloc接收一个size_t类型，那么溢出后得到一个较小的整数的话是无法被发现的，只能在malloc前对其siz做溢出检测。\n\n## Floating Point\n首先给出浮点数的一般表达式\n\n$$\nv = (-1)^s*M*2^E\n$$\n浮点数的bit-representation如下\n```\n单精度\n|s|            exp             |         frac              |\n31 30                        23 22                         0\n双精度\n|s|            exp                    |                   frac                                  |\n63 62                               52 51                                                       0\n```\n由sign, exp, frac三部分组成，sign即是符号位，exp参与E的表达，fac参与小数部分的表达，具体表达式分为Normalized values, Denormalized values, Special values情况。其中Denormalized vaules 表达的是接近0的数，Special values表示的是无穷，以及NaN(Not a Number)的情况，Normalized values 表示的是除上述两种情况外的一般的数。\n\n以单精度为例\n```\nNormalized values                  exp !=0 && exp !=255\nM = 1+f  E = e - bias   e is the value of the bit representation (exp)\nDenormalized values\nM = f    E = 1 - bias\nSpecial values\n1. Infinite\nexp = all 1  f = 0\n2. NaN\nexp = all 1 f != 0\n```\nbias = $2^(k-1) - 1$, 127 for single precision and 1023 for double。So the exponent ranges form -126~127 for single precision and -1022~1023 for doulbe.\n采用这中方式编码的好处：如果采用类似U/T的编码方式，那么会丢失精度，而且所表达的范围也会变小\n\n### Floating Points Arithmetic\n\n#### Addition\n两步走：1.向较大的E（指数位）对齐 2.相加再调整M、E。\n```\n   |         (-1)^s1*M1             |\n          |      (-1)^s2*M2                       |\n\t\t                            |----E1-E2----|\n```\n显然当大数+小数时，小数的精度丢失比较严重,所以不满足结合律。而且加法满足单调性，a>b => a+x > b+x, 只要x不为NaN即可。\n加法的性质：\n- 闭合（可能产生无穷/NaN）\n- 满足交换律\n- 不满足结合律\n- 存在逆元\n- 满足单调性\n\n#### Muplication\n- 满足交换律\n- 不满足结合律\n- 不满足乘法分配率\n- 满足单调性\na>=b and c>=0  => ac>=bc, c<=0时亦然，只要c不为NaN即可。\n\n#### compare to integer\ninteger的运算满足交换律，结合律，分配律，但不满足单调性的原理。Floating Point的运算满足交换律，不满足分配律、结合律，但是满足单调性原理。\n\n\n> Tips:关于FP不满足结合律的问题：自然界中的问题很多都是连续的，也就是说在某些状况下是不会出现极大值与极小值运算的情形，也就不用考虑不满足结合率带来的影响，但是在其他的情景下，如金融中是可能出现的。这也提醒我们要时刻把握具体情景，从需求出发。\n\n#### conversion\nfloat int double 之间的转变是改变位表示的，double/float cast 为 int是需要向0取整（NaN可能转为Tmin），int cast to double 不会出现问题，int cast to float可能要round。\n\n\n","source":"_posts/Bits-Intergers-Floating-Points.md","raw":"---\ntitle: Bits & Intergers & Floating Points\ndate: 2021-07-28 22:01:50\ntags:\nmathjax: true\n---\n\n# Bits & Interters & Floating Points\n\n## Bit\n计算机以二进制理解世界，也就是一串0和1，重要的是bit representation（二进制表示）以及 decoding（解读方式)。\n以文件的传输为例，ASCII文件中的文字首先被编码成二进制形式，然后发送给接收者，接收端以一定的规则解码得到原来的文件。\n```\n发送者 (encoding) ------> 01100110 (decoding)------> 接收者\n```\ndecoding方式带来的影响：\n```\n以4-bit的data type 为例\n1111 --       int     --> -1\n1111 --  unsigned int --> 15\n```\n由于 int 采用补码形式表示，而usigned不是导致值不同（后文详解）\n\n### Data Size\n1 bit 即是1个0或1，8 bits == 1 byte, 16 bits == 2 bytes == 1 words\nword size 就是指针所占的字位数\n\n### Address\n当我们谈到计算机的内存与地址时，一般指的是虚拟内存，每一bit都有它的地址\n### Byte Ordering\n既然bit都有自己的地址，那么连续的bits的地址一定是连续的，它们存储方式有两种big endian, little endian。\n```\naddress        0x100  0x101  0x102 0x103\nbig endian        01     23     45    67\nlittle endian     67     45     23    01\n```\nbig endian 即是大地址结尾，而little endian 即是以小地址结尾。\n在我的机子上，其以little endian方式存储，可以用以下的C代码验证\n```C\n#include <stdio.h>\n\nvoid show_bytes(char* c_p, size_t n)\n{i\n\t\tfor(size_t i = 0; i<n; i++)\n\t\t{\n\t\t\t\tprintf(\"%X \", *c_p);\n\t\t\t\tc_p++;\n\t\t}\n\t\tputs(\"\");\n}\n\nint main(void)\n{\n\tint m = 0x12345678;\n\tprintf(\"%X\\n\", m);\n\tshow_bytes((char*)(&m), sizeof(int));\n\t\n\treturn 0;\n}\n```\n\n```bash\n./endian\n12345678\n78 56 34 12  \n```\n\n了解大小端的意义如下：\n- 网络传输大多用big-endian, 而计算机一般用little-endian\n- 汇编、机器码的顺序\n- C中的cast操作，如union可能带来问题\n\n### String (ASCII)\n由于ASCII的范围0~127，每一次都读取一个byte，所以不受大小端的影响\n\n---\n\n## Intergers\n\n\n### Unsigned & Two's Complement\n\n假设有一个data的bit vector, [w<sub>k-1</sub>, w<sub>k-2</sub> .. w<sub>0</sub>], unsigned : 求和每一位的2的次幂乘以w<sub>x</sub>, Two's Complement ： 第一位为符号位，其拥有负权重2<sub>k-1</sup>。\n\n这也即当符号为为1时，其值为负而0为正的原因：最大的负数 -1 ： 2<sub>k-1</sup> + (2<sub>k-1</sup> -1)，同时记U至T的转换为U2T(x) = x<sub>t</sub> - w<sub>k-1</sub> * 2<sub>k</sup>\n\n---\n\n### Bit-Level Operations\n&（位与） |（位或）^(异或) >>（右移） <<(左移)\t~(取补码)\n```\n&  0 1       |  0 1     ^ 0 1    ~ 0 1\n0  0 0       0  0 1     0 0 1      \n1  0 1       1  1 1     1 1 0      1 0\n```\n\n#### 关于 &,&&　　|,|| \n当逻辑运算符&&，||操作的对象为一个bit时，相当于&, |\n\n#### 关于~\n**x　+　~x+1　=　0**　也即~x+1为x的加法逆元\n\n#### 关于 ^\n* 用于Floating Points符号位的计算较为方便（NaN除外）, 相当于求其加法逆元(Integers用~x+1方便)\n* x^x = 0\n\n####  左移　右移\n左移、右移顾名思义就是将bit vector向左、右移动，多出来的bit自然舍去，问题在于缺少的bit位是用0/1来补，而这在U/T的表现又不同\n\nU/T 左移 ： 用0补齐缺少位，称为逻辑左移\n\nU 右移 ： 用0补齐缺少位，称为逻辑右移\n\nT 右移 ： 补齐位与符号位一致，可以为0/1，称为算术右移\n　\n左移k位，所有对应位的权重都增大k,相当于乘以 2<sub>k</sup>  （int符号位虽然是负权重，但是结果相同）\n\n右移k位，所有对应位的权重都减少k,相当于除以 2<sub>k</sup> ,需要注意的是结果需要**Rounding**(取整)。C中的整数取整都是向0取整，而应用>>时正数：向下取整，也即向0取整，而对于负数来说，其依然是向下取整，所有需要加上相应的bias,使其满足向0取整。bias = 1 << k-1\n\n### Conversion\n转变分为三种\n- int 与 unsigned int\n- 小字节类型转大字节类型\n- 大字节类型转小字节类型\n\nint 与 unsigned int 的转换在C中并不改变其bit-represention,只是改变其解读形式。\n\n大字节转小字节则是要截断高位。\n\n小字节转大字节，则需要拓展高位，这其中又分为sign expansion && zero expansion。\n\n　　首先考虑U-U的小转大，采用零拓展，即高位全用0填补。\n　　T-T的拓展，采用符号拓展，即高位拓展取决与符号为。\n　　那么U-T,T-U的小字节转大字节是怎么实现的呢？规律是先变size再改变类型。也就是其拓展与改变前的拓展类型一致，举例如下：\n```C\n#include <stdio.h>\n\nint main(void)\n{\n\tunsigned short int s_u = 0xcfff;\n\tshort int s_t = 0xcfff;\n\tint i_u = (int)s_u;\n\tint i_t = (int)s_t;\n\tprintf(\"i_u : %x\\n\", i_u);\n\tprintf(\"i_t : %x\\n\", i_t);\n\treturn 0;\n}\n```\n```bash\ni_u : cfff\ni_t : ffffcfff\n```\n\n### Integers Arithmetic\n\n这些运算以及数据本身构成了群，如无整型与加法构成了无整型加群，在这里引入群中的一个概念，加法逆元，若a+b=0，则称b为a的逆元。\n\n#### Modular addition\n加法其实是Modualr addition,即对最后的结果取模。\n```C\n        U                    T\n\t x=0:    x          x=Tmin: Tmin \n-x                         \n\t x>0:   2**w - x    x>Tmin: -x\n\n\n溢出检测：\n     !(x + y < x)       !(x<0 && y<0 && sum >=0) && !(x>=0 && y>=0 && sum<0) (OR !((x<0 == y<0) && (sum<0 != x<0)))\n```\n加法逆元的C表达式：\n> ~x+1\n\n#### Muplication\nunsigned 计算时同样时将结果mod 2<sub>w</sub>, signed计算则是先将其转为unsigned计算，最后转回signed。这也同样表明了两种类型的乘法运算结果truncted后的bit-representation是一样的。\n\n溢出检测的两种方式：\n```C\n///1.群的性质\nint tmult_ok(int x, int y)\n{\n\tint p = x*y;\n\treturn !x || p/x == y;\n}\n\n///2.用更大的数位表示\nint tmult_ok(int x, int y)\n{\n\tin64_t pll = (in64_t)x*y;\n\treturn pll == (int)pll;\n}\n\n```\n> Tips : size_t被定义为unsigned类型，而malloc接收一个size_t类型，那么溢出后得到一个较小的整数的话是无法被发现的，只能在malloc前对其siz做溢出检测。\n\n## Floating Point\n首先给出浮点数的一般表达式\n\n$$\nv = (-1)^s*M*2^E\n$$\n浮点数的bit-representation如下\n```\n单精度\n|s|            exp             |         frac              |\n31 30                        23 22                         0\n双精度\n|s|            exp                    |                   frac                                  |\n63 62                               52 51                                                       0\n```\n由sign, exp, frac三部分组成，sign即是符号位，exp参与E的表达，fac参与小数部分的表达，具体表达式分为Normalized values, Denormalized values, Special values情况。其中Denormalized vaules 表达的是接近0的数，Special values表示的是无穷，以及NaN(Not a Number)的情况，Normalized values 表示的是除上述两种情况外的一般的数。\n\n以单精度为例\n```\nNormalized values                  exp !=0 && exp !=255\nM = 1+f  E = e - bias   e is the value of the bit representation (exp)\nDenormalized values\nM = f    E = 1 - bias\nSpecial values\n1. Infinite\nexp = all 1  f = 0\n2. NaN\nexp = all 1 f != 0\n```\nbias = $2^(k-1) - 1$, 127 for single precision and 1023 for double。So the exponent ranges form -126~127 for single precision and -1022~1023 for doulbe.\n采用这中方式编码的好处：如果采用类似U/T的编码方式，那么会丢失精度，而且所表达的范围也会变小\n\n### Floating Points Arithmetic\n\n#### Addition\n两步走：1.向较大的E（指数位）对齐 2.相加再调整M、E。\n```\n   |         (-1)^s1*M1             |\n          |      (-1)^s2*M2                       |\n\t\t                            |----E1-E2----|\n```\n显然当大数+小数时，小数的精度丢失比较严重,所以不满足结合律。而且加法满足单调性，a>b => a+x > b+x, 只要x不为NaN即可。\n加法的性质：\n- 闭合（可能产生无穷/NaN）\n- 满足交换律\n- 不满足结合律\n- 存在逆元\n- 满足单调性\n\n#### Muplication\n- 满足交换律\n- 不满足结合律\n- 不满足乘法分配率\n- 满足单调性\na>=b and c>=0  => ac>=bc, c<=0时亦然，只要c不为NaN即可。\n\n#### compare to integer\ninteger的运算满足交换律，结合律，分配律，但不满足单调性的原理。Floating Point的运算满足交换律，不满足分配律、结合律，但是满足单调性原理。\n\n\n> Tips:关于FP不满足结合律的问题：自然界中的问题很多都是连续的，也就是说在某些状况下是不会出现极大值与极小值运算的情形，也就不用考虑不满足结合率带来的影响，但是在其他的情景下，如金融中是可能出现的。这也提醒我们要时刻把握具体情景，从需求出发。\n\n#### conversion\nfloat int double 之间的转变是改变位表示的，double/float cast 为 int是需要向0取整（NaN可能转为Tmin），int cast to double 不会出现问题，int cast to float可能要round。\n\n\n","slug":"Bits-Intergers-Floating-Points","published":1,"updated":"2021-08-02T03:14:59.900Z","_id":"ckrnkqmec0000gckk2sozbnip","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Bits-amp-Interters-amp-Floating-Points\"><a href=\"#Bits-amp-Interters-amp-Floating-Points\" class=\"headerlink\" title=\"Bits &amp; Interters &amp; Floating Points\"></a>Bits &amp; Interters &amp; Floating Points</h1><h2 id=\"Bit\"><a href=\"#Bit\" class=\"headerlink\" title=\"Bit\"></a>Bit</h2><p>计算机以二进制理解世界，也就是一串0和1，重要的是bit representation（二进制表示）以及 decoding（解读方式)。<br>以文件的传输为例，ASCII文件中的文字首先被编码成二进制形式，然后发送给接收者，接收端以一定的规则解码得到原来的文件。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发送者 (encoding) ------&gt; 01100110 (decoding)------&gt; 接收者</span><br></pre></td></tr></table></figure><br>decoding方式带来的影响：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以4-bit的data type 为例</span><br><span class=\"line\">1111 --       int     --&gt; -1</span><br><span class=\"line\">1111 --  unsigned int --&gt; 15</span><br></pre></td></tr></table></figure><br>由于 int 采用补码形式表示，而usigned不是导致值不同（后文详解）</p>\n<h3 id=\"Data-Size\"><a href=\"#Data-Size\" class=\"headerlink\" title=\"Data Size\"></a>Data Size</h3><p>1 bit 即是1个0或1，8 bits == 1 byte, 16 bits == 2 bytes == 1 words<br>word size 就是指针所占的字位数</p>\n<h3 id=\"Address\"><a href=\"#Address\" class=\"headerlink\" title=\"Address\"></a>Address</h3><p>当我们谈到计算机的内存与地址时，一般指的是虚拟内存，每一bit都有它的地址</p>\n<h3 id=\"Byte-Ordering\"><a href=\"#Byte-Ordering\" class=\"headerlink\" title=\"Byte Ordering\"></a>Byte Ordering</h3><p>既然bit都有自己的地址，那么连续的bits的地址一定是连续的，它们存储方式有两种big endian, little endian。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address        0x100  0x101  0x102 0x103</span><br><span class=\"line\">big endian        01     23     45    67</span><br><span class=\"line\">little endian     67     45     23    01</span><br></pre></td></tr></table></figure><br>big endian 即是大地址结尾，而little endian 即是以小地址结尾。<br>在我的机子上，其以little endian方式存储，可以用以下的C代码验证<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_bytes</span><span class=\"params\">(<span class=\"keyword\">char</span>* c_p, <span class=\"keyword\">size_t</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"function\">i</span></span><br><span class=\"line\"><span class=\"function\">\t\t<span class=\"title\">for</span><span class=\"params\">(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i&lt;n; i++)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%X &quot;</span>, *c_p);</span><br><span class=\"line\">\t\t\t\tc_p++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m = <span class=\"number\">0x12345678</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%X\\n&quot;</span>, m);</span><br><span class=\"line\">\tshow_bytes((<span class=\"keyword\">char</span>*)(&amp;m), <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./endian</span><br><span class=\"line\">12345678</span><br><span class=\"line\">78 56 34 12  </span><br></pre></td></tr></table></figure>\n<p>了解大小端的意义如下：</p>\n<ul>\n<li>网络传输大多用big-endian, 而计算机一般用little-endian</li>\n<li>汇编、机器码的顺序</li>\n<li>C中的cast操作，如union可能带来问题</li>\n</ul>\n<h3 id=\"String-ASCII\"><a href=\"#String-ASCII\" class=\"headerlink\" title=\"String (ASCII)\"></a>String (ASCII)</h3><p>由于ASCII的范围0~127，每一次都读取一个byte，所以不受大小端的影响</p>\n<hr>\n<h2 id=\"Intergers\"><a href=\"#Intergers\" class=\"headerlink\" title=\"Intergers\"></a>Intergers</h2><h3 id=\"Unsigned-amp-Two’s-Complement\"><a href=\"#Unsigned-amp-Two’s-Complement\" class=\"headerlink\" title=\"Unsigned &amp; Two’s Complement\"></a>Unsigned &amp; Two’s Complement</h3><p>假设有一个data的bit vector, [w<sub>k-1</sub>, w<sub>k-2</sub> .. w<sub>0</sub>], unsigned : 求和每一位的2的次幂乘以w<sub>x</sub>, Two’s Complement ： 第一位为符号位，其拥有负权重2<sub>k-1&lt;/sup&gt;。</p>\n<p>这也即当符号为为1时，其值为负而0为正的原因：最大的负数 -1 ： 2<sub>k-1&lt;/sup&gt; + (2<sub>k-1&lt;/sup&gt; -1)，同时记U至T的转换为U2T(x) = x<sub>t</sub> - w<sub>k-1</sub> * 2<sub>k&lt;/sup&gt;</p>\n<hr>\n<h3 id=\"Bit-Level-Operations\"><a href=\"#Bit-Level-Operations\" class=\"headerlink\" title=\"Bit-Level Operations\"></a>Bit-Level Operations</h3><p>&amp;（位与） |（位或）^(异或) &gt;&gt;（右移） &lt;&lt;(左移)    ~(取补码)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;  0 1       |  0 1     ^ 0 1    ~ 0 1</span><br><span class=\"line\">0  0 0       0  0 1     0 0 1      </span><br><span class=\"line\">1  0 1       1  1 1     1 1 0      1 0</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"关于-amp-amp-amp\"><a href=\"#关于-amp-amp-amp\" class=\"headerlink\" title=\"关于 &amp;,&amp;&amp;　　|,||\"></a>关于 &amp;,&amp;&amp;　　|,||</h4><p>当逻辑运算符&amp;&amp;，||操作的对象为一个bit时，相当于&amp;, |</p>\n<h4 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于~\"></a>关于~</h4><p><strong>x　+　~x+1　=　0</strong>　也即~x+1为x的加法逆元</p>\n<h4 id=\"关于-1\"><a href=\"#关于-1\" class=\"headerlink\" title=\"关于 ^\"></a>关于 ^</h4><ul>\n<li>用于Floating Points符号位的计算较为方便（NaN除外）, 相当于求其加法逆元(Integers用~x+1方便)</li>\n<li>x^x = 0</li>\n</ul>\n<h4 id=\"左移-右移\"><a href=\"#左移-右移\" class=\"headerlink\" title=\"左移　右移\"></a>左移　右移</h4><p>左移、右移顾名思义就是将bit vector向左、右移动，多出来的bit自然舍去，问题在于缺少的bit位是用0/1来补，而这在U/T的表现又不同</p>\n<p>U/T 左移 ： 用0补齐缺少位，称为逻辑左移</p>\n<p>U 右移 ： 用0补齐缺少位，称为逻辑右移</p>\n<p>T 右移 ： 补齐位与符号位一致，可以为0/1，称为算术右移<br>　<br>左移k位，所有对应位的权重都增大k,相当于乘以 2<sub>k&lt;/sup&gt;  （int符号位虽然是负权重，但是结果相同）</p>\n<p>右移k位，所有对应位的权重都减少k,相当于除以 2<sub>k&lt;/sup&gt; ,需要注意的是结果需要<strong>Rounding</strong>(取整)。C中的整数取整都是向0取整，而应用&gt;&gt;时正数：向下取整，也即向0取整，而对于负数来说，其依然是向下取整，所有需要加上相应的bias,使其满足向0取整。bias = 1 &lt;&lt; k-1</p>\n<h3 id=\"Conversion\"><a href=\"#Conversion\" class=\"headerlink\" title=\"Conversion\"></a>Conversion</h3><p>转变分为三种</p>\n<ul>\n<li>int 与 unsigned int</li>\n<li>小字节类型转大字节类型</li>\n<li>大字节类型转小字节类型</li>\n</ul>\n<p>int 与 unsigned int 的转换在C中并不改变其bit-represention,只是改变其解读形式。</p>\n<p>大字节转小字节则是要截断高位。</p>\n<p>小字节转大字节，则需要拓展高位，这其中又分为sign expansion &amp;&amp; zero expansion。</p>\n<p>　　首先考虑U-U的小转大，采用零拓展，即高位全用0填补。<br>　　T-T的拓展，采用符号拓展，即高位拓展取决与符号为。<br>　　那么U-T,T-U的小字节转大字节是怎么实现的呢？规律是先变size再改变类型。也就是其拓展与改变前的拓展类型一致，举例如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> <span class=\"keyword\">int</span> s_u = <span class=\"number\">0xcfff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">short</span> <span class=\"keyword\">int</span> <span class=\"keyword\">s_t</span> = <span class=\"number\">0xcfff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i_u = (<span class=\"keyword\">int</span>)s_u;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"keyword\">i_t</span> = (<span class=\"keyword\">int</span>)<span class=\"keyword\">s_t</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i_u : %x\\n&quot;</span>, i_u);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i_t : %x\\n&quot;</span>, <span class=\"keyword\">i_t</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i_u : cfff</span><br><span class=\"line\">i_t : ffffcfff</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Integers-Arithmetic\"><a href=\"#Integers-Arithmetic\" class=\"headerlink\" title=\"Integers Arithmetic\"></a>Integers Arithmetic</h3><p>这些运算以及数据本身构成了群，如无整型与加法构成了无整型加群，在这里引入群中的一个概念，加法逆元，若a+b=0，则称b为a的逆元。</p>\n<h4 id=\"Modular-addition\"><a href=\"#Modular-addition\" class=\"headerlink\" title=\"Modular addition\"></a>Modular addition</h4><p>加法其实是Modualr addition,即对最后的结果取模。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        U                    T</span><br><span class=\"line\">\t x=<span class=\"number\">0</span>:    x          x=Tmin: Tmin </span><br><span class=\"line\">-x                         </span><br><span class=\"line\">\t x&gt;<span class=\"number\">0</span>:   <span class=\"number\">2</span>**w - x    x&gt;Tmin: -x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">溢出检测：</span><br><span class=\"line\">     !(x + y &lt; x)       !(x&lt;<span class=\"number\">0</span> &amp;&amp; y&lt;<span class=\"number\">0</span> &amp;&amp; sum &gt;=<span class=\"number\">0</span>) &amp;&amp; !(x&gt;=<span class=\"number\">0</span> &amp;&amp; y&gt;=<span class=\"number\">0</span> &amp;&amp; sum&lt;<span class=\"number\">0</span>) (OR !((x&lt;<span class=\"number\">0</span> == y&lt;<span class=\"number\">0</span>) &amp;&amp; (sum&lt;<span class=\"number\">0</span> != x&lt;<span class=\"number\">0</span>)))</span><br></pre></td></tr></table></figure><br>加法逆元的C表达式：</p>\n<blockquote>\n<p>~x+1</p>\n</blockquote>\n<h4 id=\"Muplication\"><a href=\"#Muplication\" class=\"headerlink\" title=\"Muplication\"></a>Muplication</h4><p>unsigned 计算时同样时将结果mod 2<sub>w</sub>, signed计算则是先将其转为unsigned计算，最后转回signed。这也同样表明了两种类型的乘法运算结果truncted后的bit-representation是一样的。</p>\n<p>溢出检测的两种方式：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///1.群的性质</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmult_ok</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = x*y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !x || p/x == y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///2.用更大的数位表示</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmult_ok</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">in64_t</span> pll = (<span class=\"keyword\">in64_t</span>)x*y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pll == (<span class=\"keyword\">int</span>)pll;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Tips : size_t被定义为unsigned类型，而malloc接收一个size_t类型，那么溢出后得到一个较小的整数的话是无法被发现的，只能在malloc前对其siz做溢出检测。</p>\n</blockquote>\n<h2 id=\"Floating-Point\"><a href=\"#Floating-Point\" class=\"headerlink\" title=\"Floating Point\"></a>Floating Point</h2><p>首先给出浮点数的一般表达式</p>\n<script type=\"math/tex; mode=display\">\nv = (-1)^s*M*2^E</script><p>浮点数的bit-representation如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">单精度</span><br><span class=\"line\">|s|            exp             |         frac              |</span><br><span class=\"line\">31 30                        23 22                         0</span><br><span class=\"line\">双精度</span><br><span class=\"line\">|s|            exp                    |                   frac                                  |</span><br><span class=\"line\">63 62                               52 51                                                       0</span><br></pre></td></tr></table></figure><br>由sign, exp, frac三部分组成，sign即是符号位，exp参与E的表达，fac参与小数部分的表达，具体表达式分为Normalized values, Denormalized values, Special values情况。其中Denormalized vaules 表达的是接近0的数，Special values表示的是无穷，以及NaN(Not a Number)的情况，Normalized values 表示的是除上述两种情况外的一般的数。</p>\n<p>以单精度为例<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Normalized values                  exp !=0 &amp;&amp; exp !=255</span><br><span class=\"line\">M = 1+f  E = e - bias   e is the value of the bit representation (exp)</span><br><span class=\"line\">Denormalized values</span><br><span class=\"line\">M = f    E = 1 - bias</span><br><span class=\"line\">Special values</span><br><span class=\"line\">1. Infinite</span><br><span class=\"line\">exp = all 1  f = 0</span><br><span class=\"line\">2. NaN</span><br><span class=\"line\">exp = all 1 f != 0</span><br></pre></td></tr></table></figure><br>bias = $2^(k-1) - 1$, 127 for single precision and 1023 for double。So the exponent ranges form -126~127 for single precision and -1022~1023 for doulbe.<br>采用这中方式编码的好处：如果采用类似U/T的编码方式，那么会丢失精度，而且所表达的范围也会变小</p>\n<h3 id=\"Floating-Points-Arithmetic\"><a href=\"#Floating-Points-Arithmetic\" class=\"headerlink\" title=\"Floating Points Arithmetic\"></a>Floating Points Arithmetic</h3><h4 id=\"Addition\"><a href=\"#Addition\" class=\"headerlink\" title=\"Addition\"></a>Addition</h4><p>两步走：1.向较大的E（指数位）对齐 2.相加再调整M、E。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|         (-1)^s1*M1             |</span><br><span class=\"line\">       |      (-1)^s2*M2                       |</span><br><span class=\"line\">                           |----E1-E2----|</span><br></pre></td></tr></table></figure><br>显然当大数+小数时，小数的精度丢失比较严重,所以不满足结合律。而且加法满足单调性，a&gt;b =&gt; a+x &gt; b+x, 只要x不为NaN即可。<br>加法的性质：</p>\n<ul>\n<li>闭合（可能产生无穷/NaN）</li>\n<li>满足交换律</li>\n<li>不满足结合律</li>\n<li>存在逆元</li>\n<li>满足单调性</li>\n</ul>\n<h4 id=\"Muplication-1\"><a href=\"#Muplication-1\" class=\"headerlink\" title=\"Muplication\"></a>Muplication</h4><ul>\n<li>满足交换律</li>\n<li>不满足结合律</li>\n<li>不满足乘法分配率</li>\n<li>满足单调性<br>a&gt;=b and c&gt;=0  =&gt; ac&gt;=bc, c&lt;=0时亦然，只要c不为NaN即可。</li>\n</ul>\n<h4 id=\"compare-to-integer\"><a href=\"#compare-to-integer\" class=\"headerlink\" title=\"compare to integer\"></a>compare to integer</h4><p>integer的运算满足交换律，结合律，分配律，但不满足单调性的原理。Floating Point的运算满足交换律，不满足分配律、结合律，但是满足单调性原理。</p>\n<blockquote>\n<p>Tips:关于FP不满足结合律的问题：自然界中的问题很多都是连续的，也就是说在某些状况下是不会出现极大值与极小值运算的情形，也就不用考虑不满足结合率带来的影响，但是在其他的情景下，如金融中是可能出现的。这也提醒我们要时刻把握具体情景，从需求出发。</p>\n</blockquote>\n<h4 id=\"conversion\"><a href=\"#conversion\" class=\"headerlink\" title=\"conversion\"></a>conversion</h4><p>float int double 之间的转变是改变位表示的，double/float cast 为 int是需要向0取整（NaN可能转为Tmin），int cast to double 不会出现问题，int cast to float可能要round。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Bits-amp-Interters-amp-Floating-Points\"><a href=\"#Bits-amp-Interters-amp-Floating-Points\" class=\"headerlink\" title=\"Bits &amp; Interters &amp; Floating Points\"></a>Bits &amp; Interters &amp; Floating Points</h1><h2 id=\"Bit\"><a href=\"#Bit\" class=\"headerlink\" title=\"Bit\"></a>Bit</h2><p>计算机以二进制理解世界，也就是一串0和1，重要的是bit representation（二进制表示）以及 decoding（解读方式)。<br>以文件的传输为例，ASCII文件中的文字首先被编码成二进制形式，然后发送给接收者，接收端以一定的规则解码得到原来的文件。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">发送者 (encoding) ------&gt; 01100110 (decoding)------&gt; 接收者</span><br></pre></td></tr></table></figure><br>decoding方式带来的影响：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以4-bit的data type 为例</span><br><span class=\"line\">1111 --       int     --&gt; -1</span><br><span class=\"line\">1111 --  unsigned int --&gt; 15</span><br></pre></td></tr></table></figure><br>由于 int 采用补码形式表示，而usigned不是导致值不同（后文详解）</p>\n<h3 id=\"Data-Size\"><a href=\"#Data-Size\" class=\"headerlink\" title=\"Data Size\"></a>Data Size</h3><p>1 bit 即是1个0或1，8 bits == 1 byte, 16 bits == 2 bytes == 1 words<br>word size 就是指针所占的字位数</p>\n<h3 id=\"Address\"><a href=\"#Address\" class=\"headerlink\" title=\"Address\"></a>Address</h3><p>当我们谈到计算机的内存与地址时，一般指的是虚拟内存，每一bit都有它的地址</p>\n<h3 id=\"Byte-Ordering\"><a href=\"#Byte-Ordering\" class=\"headerlink\" title=\"Byte Ordering\"></a>Byte Ordering</h3><p>既然bit都有自己的地址，那么连续的bits的地址一定是连续的，它们存储方式有两种big endian, little endian。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address        0x100  0x101  0x102 0x103</span><br><span class=\"line\">big endian        01     23     45    67</span><br><span class=\"line\">little endian     67     45     23    01</span><br></pre></td></tr></table></figure><br>big endian 即是大地址结尾，而little endian 即是以小地址结尾。<br>在我的机子上，其以little endian方式存储，可以用以下的C代码验证<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_bytes</span><span class=\"params\">(<span class=\"keyword\">char</span>* c_p, <span class=\"keyword\">size_t</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"function\">i</span></span><br><span class=\"line\"><span class=\"function\">\t\t<span class=\"title\">for</span><span class=\"params\">(<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i&lt;n; i++)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%X &quot;</span>, *c_p);</span><br><span class=\"line\">\t\t\t\tc_p++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">puts</span>(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m = <span class=\"number\">0x12345678</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%X\\n&quot;</span>, m);</span><br><span class=\"line\">\tshow_bytes((<span class=\"keyword\">char</span>*)(&amp;m), <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./endian</span><br><span class=\"line\">12345678</span><br><span class=\"line\">78 56 34 12  </span><br></pre></td></tr></table></figure>\n<p>了解大小端的意义如下：</p>\n<ul>\n<li>网络传输大多用big-endian, 而计算机一般用little-endian</li>\n<li>汇编、机器码的顺序</li>\n<li>C中的cast操作，如union可能带来问题</li>\n</ul>\n<h3 id=\"String-ASCII\"><a href=\"#String-ASCII\" class=\"headerlink\" title=\"String (ASCII)\"></a>String (ASCII)</h3><p>由于ASCII的范围0~127，每一次都读取一个byte，所以不受大小端的影响</p>\n<hr>\n<h2 id=\"Intergers\"><a href=\"#Intergers\" class=\"headerlink\" title=\"Intergers\"></a>Intergers</h2><h3 id=\"Unsigned-amp-Two’s-Complement\"><a href=\"#Unsigned-amp-Two’s-Complement\" class=\"headerlink\" title=\"Unsigned &amp; Two’s Complement\"></a>Unsigned &amp; Two’s Complement</h3><p>假设有一个data的bit vector, [w<sub>k-1</sub>, w<sub>k-2</sub> .. w<sub>0</sub>], unsigned : 求和每一位的2的次幂乘以w<sub>x</sub>, Two’s Complement ： 第一位为符号位，其拥有负权重2<sub>k-1&lt;/sup&gt;。</p>\n<p>这也即当符号为为1时，其值为负而0为正的原因：最大的负数 -1 ： 2<sub>k-1&lt;/sup&gt; + (2<sub>k-1&lt;/sup&gt; -1)，同时记U至T的转换为U2T(x) = x<sub>t</sub> - w<sub>k-1</sub> * 2<sub>k&lt;/sup&gt;</p>\n<hr>\n<h3 id=\"Bit-Level-Operations\"><a href=\"#Bit-Level-Operations\" class=\"headerlink\" title=\"Bit-Level Operations\"></a>Bit-Level Operations</h3><p>&amp;（位与） |（位或）^(异或) &gt;&gt;（右移） &lt;&lt;(左移)    ~(取补码)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;  0 1       |  0 1     ^ 0 1    ~ 0 1</span><br><span class=\"line\">0  0 0       0  0 1     0 0 1      </span><br><span class=\"line\">1  0 1       1  1 1     1 1 0      1 0</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"关于-amp-amp-amp\"><a href=\"#关于-amp-amp-amp\" class=\"headerlink\" title=\"关于 &amp;,&amp;&amp;　　|,||\"></a>关于 &amp;,&amp;&amp;　　|,||</h4><p>当逻辑运算符&amp;&amp;，||操作的对象为一个bit时，相当于&amp;, |</p>\n<h4 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于~\"></a>关于~</h4><p><strong>x　+　~x+1　=　0</strong>　也即~x+1为x的加法逆元</p>\n<h4 id=\"关于-1\"><a href=\"#关于-1\" class=\"headerlink\" title=\"关于 ^\"></a>关于 ^</h4><ul>\n<li>用于Floating Points符号位的计算较为方便（NaN除外）, 相当于求其加法逆元(Integers用~x+1方便)</li>\n<li>x^x = 0</li>\n</ul>\n<h4 id=\"左移-右移\"><a href=\"#左移-右移\" class=\"headerlink\" title=\"左移　右移\"></a>左移　右移</h4><p>左移、右移顾名思义就是将bit vector向左、右移动，多出来的bit自然舍去，问题在于缺少的bit位是用0/1来补，而这在U/T的表现又不同</p>\n<p>U/T 左移 ： 用0补齐缺少位，称为逻辑左移</p>\n<p>U 右移 ： 用0补齐缺少位，称为逻辑右移</p>\n<p>T 右移 ： 补齐位与符号位一致，可以为0/1，称为算术右移<br>　<br>左移k位，所有对应位的权重都增大k,相当于乘以 2<sub>k&lt;/sup&gt;  （int符号位虽然是负权重，但是结果相同）</p>\n<p>右移k位，所有对应位的权重都减少k,相当于除以 2<sub>k&lt;/sup&gt; ,需要注意的是结果需要<strong>Rounding</strong>(取整)。C中的整数取整都是向0取整，而应用&gt;&gt;时正数：向下取整，也即向0取整，而对于负数来说，其依然是向下取整，所有需要加上相应的bias,使其满足向0取整。bias = 1 &lt;&lt; k-1</p>\n<h3 id=\"Conversion\"><a href=\"#Conversion\" class=\"headerlink\" title=\"Conversion\"></a>Conversion</h3><p>转变分为三种</p>\n<ul>\n<li>int 与 unsigned int</li>\n<li>小字节类型转大字节类型</li>\n<li>大字节类型转小字节类型</li>\n</ul>\n<p>int 与 unsigned int 的转换在C中并不改变其bit-represention,只是改变其解读形式。</p>\n<p>大字节转小字节则是要截断高位。</p>\n<p>小字节转大字节，则需要拓展高位，这其中又分为sign expansion &amp;&amp; zero expansion。</p>\n<p>　　首先考虑U-U的小转大，采用零拓展，即高位全用0填补。<br>　　T-T的拓展，采用符号拓展，即高位拓展取决与符号为。<br>　　那么U-T,T-U的小字节转大字节是怎么实现的呢？规律是先变size再改变类型。也就是其拓展与改变前的拓展类型一致，举例如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> <span class=\"keyword\">int</span> s_u = <span class=\"number\">0xcfff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">short</span> <span class=\"keyword\">int</span> <span class=\"keyword\">s_t</span> = <span class=\"number\">0xcfff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i_u = (<span class=\"keyword\">int</span>)s_u;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> <span class=\"keyword\">i_t</span> = (<span class=\"keyword\">int</span>)<span class=\"keyword\">s_t</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i_u : %x\\n&quot;</span>, i_u);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;i_t : %x\\n&quot;</span>, <span class=\"keyword\">i_t</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i_u : cfff</span><br><span class=\"line\">i_t : ffffcfff</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Integers-Arithmetic\"><a href=\"#Integers-Arithmetic\" class=\"headerlink\" title=\"Integers Arithmetic\"></a>Integers Arithmetic</h3><p>这些运算以及数据本身构成了群，如无整型与加法构成了无整型加群，在这里引入群中的一个概念，加法逆元，若a+b=0，则称b为a的逆元。</p>\n<h4 id=\"Modular-addition\"><a href=\"#Modular-addition\" class=\"headerlink\" title=\"Modular addition\"></a>Modular addition</h4><p>加法其实是Modualr addition,即对最后的结果取模。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        U                    T</span><br><span class=\"line\">\t x=<span class=\"number\">0</span>:    x          x=Tmin: Tmin </span><br><span class=\"line\">-x                         </span><br><span class=\"line\">\t x&gt;<span class=\"number\">0</span>:   <span class=\"number\">2</span>**w - x    x&gt;Tmin: -x</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">溢出检测：</span><br><span class=\"line\">     !(x + y &lt; x)       !(x&lt;<span class=\"number\">0</span> &amp;&amp; y&lt;<span class=\"number\">0</span> &amp;&amp; sum &gt;=<span class=\"number\">0</span>) &amp;&amp; !(x&gt;=<span class=\"number\">0</span> &amp;&amp; y&gt;=<span class=\"number\">0</span> &amp;&amp; sum&lt;<span class=\"number\">0</span>) (OR !((x&lt;<span class=\"number\">0</span> == y&lt;<span class=\"number\">0</span>) &amp;&amp; (sum&lt;<span class=\"number\">0</span> != x&lt;<span class=\"number\">0</span>)))</span><br></pre></td></tr></table></figure><br>加法逆元的C表达式：</p>\n<blockquote>\n<p>~x+1</p>\n</blockquote>\n<h4 id=\"Muplication\"><a href=\"#Muplication\" class=\"headerlink\" title=\"Muplication\"></a>Muplication</h4><p>unsigned 计算时同样时将结果mod 2<sub>w</sub>, signed计算则是先将其转为unsigned计算，最后转回signed。这也同样表明了两种类型的乘法运算结果truncted后的bit-representation是一样的。</p>\n<p>溢出检测的两种方式：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///1.群的性质</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmult_ok</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> p = x*y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> !x || p/x == y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///2.用更大的数位表示</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tmult_ok</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">in64_t</span> pll = (<span class=\"keyword\">in64_t</span>)x*y;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pll == (<span class=\"keyword\">int</span>)pll;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Tips : size_t被定义为unsigned类型，而malloc接收一个size_t类型，那么溢出后得到一个较小的整数的话是无法被发现的，只能在malloc前对其siz做溢出检测。</p>\n</blockquote>\n<h2 id=\"Floating-Point\"><a href=\"#Floating-Point\" class=\"headerlink\" title=\"Floating Point\"></a>Floating Point</h2><p>首先给出浮点数的一般表达式</p>\n<script type=\"math/tex; mode=display\">\nv = (-1)^s*M*2^E</script><p>浮点数的bit-representation如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">单精度</span><br><span class=\"line\">|s|            exp             |         frac              |</span><br><span class=\"line\">31 30                        23 22                         0</span><br><span class=\"line\">双精度</span><br><span class=\"line\">|s|            exp                    |                   frac                                  |</span><br><span class=\"line\">63 62                               52 51                                                       0</span><br></pre></td></tr></table></figure><br>由sign, exp, frac三部分组成，sign即是符号位，exp参与E的表达，fac参与小数部分的表达，具体表达式分为Normalized values, Denormalized values, Special values情况。其中Denormalized vaules 表达的是接近0的数，Special values表示的是无穷，以及NaN(Not a Number)的情况，Normalized values 表示的是除上述两种情况外的一般的数。</p>\n<p>以单精度为例<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Normalized values                  exp !=0 &amp;&amp; exp !=255</span><br><span class=\"line\">M = 1+f  E = e - bias   e is the value of the bit representation (exp)</span><br><span class=\"line\">Denormalized values</span><br><span class=\"line\">M = f    E = 1 - bias</span><br><span class=\"line\">Special values</span><br><span class=\"line\">1. Infinite</span><br><span class=\"line\">exp = all 1  f = 0</span><br><span class=\"line\">2. NaN</span><br><span class=\"line\">exp = all 1 f != 0</span><br></pre></td></tr></table></figure><br>bias = $2^(k-1) - 1$, 127 for single precision and 1023 for double。So the exponent ranges form -126~127 for single precision and -1022~1023 for doulbe.<br>采用这中方式编码的好处：如果采用类似U/T的编码方式，那么会丢失精度，而且所表达的范围也会变小</p>\n<h3 id=\"Floating-Points-Arithmetic\"><a href=\"#Floating-Points-Arithmetic\" class=\"headerlink\" title=\"Floating Points Arithmetic\"></a>Floating Points Arithmetic</h3><h4 id=\"Addition\"><a href=\"#Addition\" class=\"headerlink\" title=\"Addition\"></a>Addition</h4><p>两步走：1.向较大的E（指数位）对齐 2.相加再调整M、E。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|         (-1)^s1*M1             |</span><br><span class=\"line\">       |      (-1)^s2*M2                       |</span><br><span class=\"line\">                           |----E1-E2----|</span><br></pre></td></tr></table></figure><br>显然当大数+小数时，小数的精度丢失比较严重,所以不满足结合律。而且加法满足单调性，a&gt;b =&gt; a+x &gt; b+x, 只要x不为NaN即可。<br>加法的性质：</p>\n<ul>\n<li>闭合（可能产生无穷/NaN）</li>\n<li>满足交换律</li>\n<li>不满足结合律</li>\n<li>存在逆元</li>\n<li>满足单调性</li>\n</ul>\n<h4 id=\"Muplication-1\"><a href=\"#Muplication-1\" class=\"headerlink\" title=\"Muplication\"></a>Muplication</h4><ul>\n<li>满足交换律</li>\n<li>不满足结合律</li>\n<li>不满足乘法分配率</li>\n<li>满足单调性<br>a&gt;=b and c&gt;=0  =&gt; ac&gt;=bc, c&lt;=0时亦然，只要c不为NaN即可。</li>\n</ul>\n<h4 id=\"compare-to-integer\"><a href=\"#compare-to-integer\" class=\"headerlink\" title=\"compare to integer\"></a>compare to integer</h4><p>integer的运算满足交换律，结合律，分配律，但不满足单调性的原理。Floating Point的运算满足交换律，不满足分配律、结合律，但是满足单调性原理。</p>\n<blockquote>\n<p>Tips:关于FP不满足结合律的问题：自然界中的问题很多都是连续的，也就是说在某些状况下是不会出现极大值与极小值运算的情形，也就不用考虑不满足结合率带来的影响，但是在其他的情景下，如金融中是可能出现的。这也提醒我们要时刻把握具体情景，从需求出发。</p>\n</blockquote>\n<h4 id=\"conversion\"><a href=\"#conversion\" class=\"headerlink\" title=\"conversion\"></a>conversion</h4><p>float int double 之间的转变是改变位表示的，double/float cast 为 int是需要向0取整（NaN可能转为Tmin），int cast to double 不会出现问题，int cast to float可能要round。</p>\n"},{"title":"Machine-Level Representation of Programs","date":"2021-08-01T02:36:57.000Z","mathjax":true,"_content":"\n# Machine-Level Representation of Programs\n\n## 编译与反汇编\n先回忆一个C文件生成程序的过程：预处理，编译，汇编，链接。现阶段的编译器对代码的优化程度大，以至于反汇编时的汇编代码产生大幅度的变形，为了学习上的理解方便，我们使用gcc -Og的指令，使其代码不在编译阶段发生变形，同时使用objdump工具反汇编程序，得到汇编代码。\n```bash\ngcc -Og prog.c -o prog\nobjdump -d prog\n```\n\n## 信息的Accessing\n\n### 寄存器\n用来暂时储存运算结果，x86-64一共有16个64bit寄存器，每个中实际上4个寄存器，分别为64, 32, 16, 8 bit.\n\n```\n63                          31               15            7          0\n-----------------------------------------------------------------------\n|%rax                         |%eax            |%ax         |%al       |\n-----------------------------------------------------------------------\n```\n### 操作符\n\n|Type|Form|Value|\n|:----:|:---:|:---:|\n|立即数|$Imm|Imm|\n|寄存器|r|寄存器内的值 R(r)|\n|内存访问|(r)|访问寄存器中的地址指向的值|\n|内存访问|Imm(rb, ri, s)|计算出的地址指向的值|\n\nrb是base register, ri 是index register, s是缩放因子取1， 2， 4， 8，也即是数据类型的byte数。Imm(rb, ri, s) = Imm + R(rb) + R(ri)`*s。\n\n\n\n\n### Data Movement Instructions\nMOV & MOVZ & MOVS\n由mov_ + b/w/l/q 组成，后缀代表的是操作数据的size。一般情况下，MOV指令只会改变寄存器的指定字节数中的值，但是**movl**是一个例外，它操作32-bit int值，但是同时将高32-bit设置为0。**movq**是另一个例外，它只接受32-bit补码表示的值，但是q暗示它处理的是4-word 64-bit的值，所以它会将其sign extend.**movabsq**只能接收一个64-bit立即数，且移动到一个寄存器中。\n\nMOVZ, MOVS 分别代表将小字节移入大字节时进行zero拓展和符号拓展。\n\n### Stack\n当内存以栈的形式使用时，有两条指令来操作stack data, pushq 等价于 subq $8, %rsp; movq %rbp, (%rsp)。popq 等价于 movq (%rsp), %rax; addq $8, %rsp。\n```\n|  高地址  |      |        |\n|          |      |        |\n|          |增长  |        |\n|  低地址  |  ==> |        |\n                  |   new  |\n\n```\n## Arithmetic and Logical Operations\n**leaq** S, D  ==>  D <-- &S。取S的地址写入D中。如leaq (%rax, %rax, 4), %rax，那么%rax的值被改为地址变量5R(%rax)+7。但是这个指令通常与地址计算无关,而是用来做计算。example:\n```\nC code:\nlong scale(long x, long y, long z)\n{\n\tlong t = x + 4*y + z;\n\treturn t;\n}\n\n汇编:\n# x in %rdi, y in %rsi, z in %rdx\n\nleaq (%rdi, %rsi, 4), %rax\nleaq (%rdx, %rdx, 2), %rdx\nleaq (%rax, %rdx, 4), %rax\nret\n\n```\n\n### 其他的一些操作符\n一元操作指令：incq, decq 分别使stack的最高8个字节自增，自减，也即++,--\n二元操作指令：addq,subq; addq %rax, %rdx  ==> R(%rdx) += R(%rax); subq %rax, %rdx ==> R(%rdx) -= R(%rax); sarq/shrq salq/shlq 分别为算数/逻辑左移，算数/逻辑右移。二元运算操作符的结果都被第二个参数保存。\n\n>Tips : 使用x^x = 0的性质：xorq %rdx, %rdx比 movq $0, %rdx更有效。\n\n\n### 特殊的一元操作符\nimulq, mulq, S 将S与R(%rax)相乘得到128-bit,其中的高64-bit存储在%rdx中，低64-bit存储在%rax中。cqto 将SignExtend(R[%rax])的结果以上述形式储存。\nidivq, divq S 将R[%rdx:%rax]模后的数存储在%rdx中，将商存储在%rax中。一般来说%rdx预先被设置为0。\n\n\n## control \n两种方式//TODO\n\n### Condition Codes\n操作指令完成后一般都alter condition code(leaq 除外)\n|type|description|\n|:---:|:---|\n|CF|检测unsigned的overflow|\n|ZF|检测是否为0|\n\n可以改变状态码而不用寄存器的两类指令：CMP，TEST。他们都不会改变参数的值。\n|Instructions|Args|Perform|\n|:---:|:---:|:---:|\n|CMP|S1 S2| **S2-S1**|\n|TEST|S1 S2|S1&S2|\n### Accessing the Condition Codes\n- 通过不同状态码的组合将寄存器的1byte设置为0或1\n- 通过状态码jump\n- 有条件地transfer data\n\njumps的编码，常用的是PC relative,用编码后的相对地址. 举例如下：\n```\n4003fa : 74 02                                    je  XXXXXX\n4003fc : ff d0                                    callq *%rax\n\n```\nXXXXXX = 4003fc + 0x02 = 4003fe\n\n\n## Procedures\n\n## Arrary Allocation and Access\n\n## Heterogeneous Data Structures\n\n## \n\n","source":"_posts/Machine-Level-Representation-of-Programs.md","raw":"---\ntitle: Machine-Level Representation of Programs\ndate: 2021-08-01 10:36:57\ntags:\nmathjax: true\n---\n\n# Machine-Level Representation of Programs\n\n## 编译与反汇编\n先回忆一个C文件生成程序的过程：预处理，编译，汇编，链接。现阶段的编译器对代码的优化程度大，以至于反汇编时的汇编代码产生大幅度的变形，为了学习上的理解方便，我们使用gcc -Og的指令，使其代码不在编译阶段发生变形，同时使用objdump工具反汇编程序，得到汇编代码。\n```bash\ngcc -Og prog.c -o prog\nobjdump -d prog\n```\n\n## 信息的Accessing\n\n### 寄存器\n用来暂时储存运算结果，x86-64一共有16个64bit寄存器，每个中实际上4个寄存器，分别为64, 32, 16, 8 bit.\n\n```\n63                          31               15            7          0\n-----------------------------------------------------------------------\n|%rax                         |%eax            |%ax         |%al       |\n-----------------------------------------------------------------------\n```\n### 操作符\n\n|Type|Form|Value|\n|:----:|:---:|:---:|\n|立即数|$Imm|Imm|\n|寄存器|r|寄存器内的值 R(r)|\n|内存访问|(r)|访问寄存器中的地址指向的值|\n|内存访问|Imm(rb, ri, s)|计算出的地址指向的值|\n\nrb是base register, ri 是index register, s是缩放因子取1， 2， 4， 8，也即是数据类型的byte数。Imm(rb, ri, s) = Imm + R(rb) + R(ri)`*s。\n\n\n\n\n### Data Movement Instructions\nMOV & MOVZ & MOVS\n由mov_ + b/w/l/q 组成，后缀代表的是操作数据的size。一般情况下，MOV指令只会改变寄存器的指定字节数中的值，但是**movl**是一个例外，它操作32-bit int值，但是同时将高32-bit设置为0。**movq**是另一个例外，它只接受32-bit补码表示的值，但是q暗示它处理的是4-word 64-bit的值，所以它会将其sign extend.**movabsq**只能接收一个64-bit立即数，且移动到一个寄存器中。\n\nMOVZ, MOVS 分别代表将小字节移入大字节时进行zero拓展和符号拓展。\n\n### Stack\n当内存以栈的形式使用时，有两条指令来操作stack data, pushq 等价于 subq $8, %rsp; movq %rbp, (%rsp)。popq 等价于 movq (%rsp), %rax; addq $8, %rsp。\n```\n|  高地址  |      |        |\n|          |      |        |\n|          |增长  |        |\n|  低地址  |  ==> |        |\n                  |   new  |\n\n```\n## Arithmetic and Logical Operations\n**leaq** S, D  ==>  D <-- &S。取S的地址写入D中。如leaq (%rax, %rax, 4), %rax，那么%rax的值被改为地址变量5R(%rax)+7。但是这个指令通常与地址计算无关,而是用来做计算。example:\n```\nC code:\nlong scale(long x, long y, long z)\n{\n\tlong t = x + 4*y + z;\n\treturn t;\n}\n\n汇编:\n# x in %rdi, y in %rsi, z in %rdx\n\nleaq (%rdi, %rsi, 4), %rax\nleaq (%rdx, %rdx, 2), %rdx\nleaq (%rax, %rdx, 4), %rax\nret\n\n```\n\n### 其他的一些操作符\n一元操作指令：incq, decq 分别使stack的最高8个字节自增，自减，也即++,--\n二元操作指令：addq,subq; addq %rax, %rdx  ==> R(%rdx) += R(%rax); subq %rax, %rdx ==> R(%rdx) -= R(%rax); sarq/shrq salq/shlq 分别为算数/逻辑左移，算数/逻辑右移。二元运算操作符的结果都被第二个参数保存。\n\n>Tips : 使用x^x = 0的性质：xorq %rdx, %rdx比 movq $0, %rdx更有效。\n\n\n### 特殊的一元操作符\nimulq, mulq, S 将S与R(%rax)相乘得到128-bit,其中的高64-bit存储在%rdx中，低64-bit存储在%rax中。cqto 将SignExtend(R[%rax])的结果以上述形式储存。\nidivq, divq S 将R[%rdx:%rax]模后的数存储在%rdx中，将商存储在%rax中。一般来说%rdx预先被设置为0。\n\n\n## control \n两种方式//TODO\n\n### Condition Codes\n操作指令完成后一般都alter condition code(leaq 除外)\n|type|description|\n|:---:|:---|\n|CF|检测unsigned的overflow|\n|ZF|检测是否为0|\n\n可以改变状态码而不用寄存器的两类指令：CMP，TEST。他们都不会改变参数的值。\n|Instructions|Args|Perform|\n|:---:|:---:|:---:|\n|CMP|S1 S2| **S2-S1**|\n|TEST|S1 S2|S1&S2|\n### Accessing the Condition Codes\n- 通过不同状态码的组合将寄存器的1byte设置为0或1\n- 通过状态码jump\n- 有条件地transfer data\n\njumps的编码，常用的是PC relative,用编码后的相对地址. 举例如下：\n```\n4003fa : 74 02                                    je  XXXXXX\n4003fc : ff d0                                    callq *%rax\n\n```\nXXXXXX = 4003fc + 0x02 = 4003fe\n\n\n## Procedures\n\n## Arrary Allocation and Access\n\n## Heterogeneous Data Structures\n\n## \n\n","slug":"Machine-Level-Representation-of-Programs","published":1,"updated":"2021-08-01T23:52:53.608Z","_id":"ckrsmhqht0000zhkk7mplcltu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Machine-Level-Representation-of-Programs\"><a href=\"#Machine-Level-Representation-of-Programs\" class=\"headerlink\" title=\"Machine-Level Representation of Programs\"></a>Machine-Level Representation of Programs</h1><h2 id=\"编译与反汇编\"><a href=\"#编译与反汇编\" class=\"headerlink\" title=\"编译与反汇编\"></a>编译与反汇编</h2><p>先回忆一个C文件生成程序的过程：预处理，编译，汇编，链接。现阶段的编译器对代码的优化程度大，以至于反汇编时的汇编代码产生大幅度的变形，为了学习上的理解方便，我们使用gcc -Og的指令，使其代码不在编译阶段发生变形，同时使用objdump工具反汇编程序，得到汇编代码。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -Og prog.c -o prog</span><br><span class=\"line\">objdump -d prog</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"信息的Accessing\"><a href=\"#信息的Accessing\" class=\"headerlink\" title=\"信息的Accessing\"></a>信息的Accessing</h2><h3 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h3><p>用来暂时储存运算结果，x86-64一共有16个64bit寄存器，每个中实际上4个寄存器，分别为64, 32, 16, 8 bit.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">63                          31               15            7          0</span><br><span class=\"line\">-----------------------------------------------------------------------</span><br><span class=\"line\">|%rax                         |%eax            |%ax         |%al       |</span><br><span class=\"line\">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Type</th>\n<th style=\"text-align:center\">Form</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">立即数</td>\n<td style=\"text-align:center\">$Imm</td>\n<td style=\"text-align:center\">Imm</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寄存器</td>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">寄存器内的值 R(r)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存访问</td>\n<td style=\"text-align:center\">(r)</td>\n<td style=\"text-align:center\">访问寄存器中的地址指向的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存访问</td>\n<td style=\"text-align:center\">Imm(rb, ri, s)</td>\n<td style=\"text-align:center\">计算出的地址指向的值</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>rb是base register, ri 是index register, s是缩放因子取1， 2， 4， 8，也即是数据类型的byte数。Imm(rb, ri, s) = Imm + R(rb) + R(ri)`*s。</p>\n<h3 id=\"Data-Movement-Instructions\"><a href=\"#Data-Movement-Instructions\" class=\"headerlink\" title=\"Data Movement Instructions\"></a>Data Movement Instructions</h3><p>MOV &amp; MOVZ &amp; MOVS<br>由mov_ + b/w/l/q 组成，后缀代表的是操作数据的size。一般情况下，MOV指令只会改变寄存器的指定字节数中的值，但是<strong>movl</strong>是一个例外，它操作32-bit int值，但是同时将高32-bit设置为0。<strong>movq</strong>是另一个例外，它只接受32-bit补码表示的值，但是q暗示它处理的是4-word 64-bit的值，所以它会将其sign extend.<strong>movabsq</strong>只能接收一个64-bit立即数，且移动到一个寄存器中。</p>\n<p>MOVZ, MOVS 分别代表将小字节移入大字节时进行zero拓展和符号拓展。</p>\n<h3 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h3><p>当内存以栈的形式使用时，有两条指令来操作stack data, pushq 等价于 subq $8, %rsp; movq %rbp, (%rsp)。popq 等价于 movq (%rsp), %rax; addq $8, %rsp。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|  高地址  |      |        |</span><br><span class=\"line\">|          |      |        |</span><br><span class=\"line\">|          |增长  |        |</span><br><span class=\"line\">|  低地址  |  ==&gt; |        |</span><br><span class=\"line\">                  |   new  |</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Arithmetic-and-Logical-Operations\"><a href=\"#Arithmetic-and-Logical-Operations\" class=\"headerlink\" title=\"Arithmetic and Logical Operations\"></a>Arithmetic and Logical Operations</h2><p><strong>leaq</strong> S, D  ==&gt;  D &lt;— &amp;S。取S的地址写入D中。如leaq (%rax, %rax, 4), %rax，那么%rax的值被改为地址变量5R(%rax)+7。但是这个指令通常与地址计算无关,而是用来做计算。example:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C code:</span><br><span class=\"line\">long scale(long x, long y, long z)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlong t = x + 4*y + z;</span><br><span class=\"line\">\treturn t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">汇编:</span><br><span class=\"line\"># x in %rdi, y in %rsi, z in %rdx</span><br><span class=\"line\"></span><br><span class=\"line\">leaq (%rdi, %rsi, 4), %rax</span><br><span class=\"line\">leaq (%rdx, %rdx, 2), %rdx</span><br><span class=\"line\">leaq (%rax, %rdx, 4), %rax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他的一些操作符\"><a href=\"#其他的一些操作符\" class=\"headerlink\" title=\"其他的一些操作符\"></a>其他的一些操作符</h3><p>一元操作指令：incq, decq 分别使stack的最高8个字节自增，自减，也即++,—<br>二元操作指令：addq,subq; addq %rax, %rdx  ==&gt; R(%rdx) += R(%rax); subq %rax, %rdx ==&gt; R(%rdx) -= R(%rax); sarq/shrq salq/shlq 分别为算数/逻辑左移，算数/逻辑右移。二元运算操作符的结果都被第二个参数保存。</p>\n<blockquote>\n<p>Tips : 使用x^x = 0的性质：xorq %rdx, %rdx比 movq $0, %rdx更有效。</p>\n</blockquote>\n<h3 id=\"特殊的一元操作符\"><a href=\"#特殊的一元操作符\" class=\"headerlink\" title=\"特殊的一元操作符\"></a>特殊的一元操作符</h3><p>imulq, mulq, S 将S与R(%rax)相乘得到128-bit,其中的高64-bit存储在%rdx中，低64-bit存储在%rax中。cqto 将SignExtend(R[%rax])的结果以上述形式储存。<br>idivq, divq S 将R[%rdx:%rax]模后的数存储在%rdx中，将商存储在%rax中。一般来说%rdx预先被设置为0。</p>\n<h2 id=\"control\"><a href=\"#control\" class=\"headerlink\" title=\"control\"></a>control</h2><p>两种方式//TODO</p>\n<h3 id=\"Condition-Codes\"><a href=\"#Condition-Codes\" class=\"headerlink\" title=\"Condition Codes\"></a>Condition Codes</h3><p>操作指令完成后一般都alter condition code(leaq 除外)<br>|type|description|<br>|:—-:|:—-|<br>|CF|检测unsigned的overflow|<br>|ZF|检测是否为0|</p>\n<p>可以改变状态码而不用寄存器的两类指令：CMP，TEST。他们都不会改变参数的值。<br>|Instructions|Args|Perform|<br>|:—-:|:—-:|:—-:|<br>|CMP|S1 S2| <strong>S2-S1</strong>|<br>|TEST|S1 S2|S1&amp;S2|</p>\n<h3 id=\"Accessing-the-Condition-Codes\"><a href=\"#Accessing-the-Condition-Codes\" class=\"headerlink\" title=\"Accessing the Condition Codes\"></a>Accessing the Condition Codes</h3><ul>\n<li>通过不同状态码的组合将寄存器的1byte设置为0或1</li>\n<li>通过状态码jump</li>\n<li>有条件地transfer data</li>\n</ul>\n<p>jumps的编码，常用的是PC relative,用编码后的相对地址. 举例如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4003fa : 74 02                                    je  XXXXXX</span><br><span class=\"line\">4003fc : ff d0                                    callq *%rax</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>XXXXXX = 4003fc + 0x02 = 4003fe</p>\n<h2 id=\"Procedures\"><a href=\"#Procedures\" class=\"headerlink\" title=\"Procedures\"></a>Procedures</h2><h2 id=\"Arrary-Allocation-and-Access\"><a href=\"#Arrary-Allocation-and-Access\" class=\"headerlink\" title=\"Arrary Allocation and Access\"></a>Arrary Allocation and Access</h2><h2 id=\"Heterogeneous-Data-Structures\"><a href=\"#Heterogeneous-Data-Structures\" class=\"headerlink\" title=\"Heterogeneous Data Structures\"></a>Heterogeneous Data Structures</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Machine-Level-Representation-of-Programs\"><a href=\"#Machine-Level-Representation-of-Programs\" class=\"headerlink\" title=\"Machine-Level Representation of Programs\"></a>Machine-Level Representation of Programs</h1><h2 id=\"编译与反汇编\"><a href=\"#编译与反汇编\" class=\"headerlink\" title=\"编译与反汇编\"></a>编译与反汇编</h2><p>先回忆一个C文件生成程序的过程：预处理，编译，汇编，链接。现阶段的编译器对代码的优化程度大，以至于反汇编时的汇编代码产生大幅度的变形，为了学习上的理解方便，我们使用gcc -Og的指令，使其代码不在编译阶段发生变形，同时使用objdump工具反汇编程序，得到汇编代码。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -Og prog.c -o prog</span><br><span class=\"line\">objdump -d prog</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"信息的Accessing\"><a href=\"#信息的Accessing\" class=\"headerlink\" title=\"信息的Accessing\"></a>信息的Accessing</h2><h3 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h3><p>用来暂时储存运算结果，x86-64一共有16个64bit寄存器，每个中实际上4个寄存器，分别为64, 32, 16, 8 bit.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">63                          31               15            7          0</span><br><span class=\"line\">-----------------------------------------------------------------------</span><br><span class=\"line\">|%rax                         |%eax            |%ax         |%al       |</span><br><span class=\"line\">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Type</th>\n<th style=\"text-align:center\">Form</th>\n<th style=\"text-align:center\">Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">立即数</td>\n<td style=\"text-align:center\">$Imm</td>\n<td style=\"text-align:center\">Imm</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寄存器</td>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">寄存器内的值 R(r)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存访问</td>\n<td style=\"text-align:center\">(r)</td>\n<td style=\"text-align:center\">访问寄存器中的地址指向的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存访问</td>\n<td style=\"text-align:center\">Imm(rb, ri, s)</td>\n<td style=\"text-align:center\">计算出的地址指向的值</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>rb是base register, ri 是index register, s是缩放因子取1， 2， 4， 8，也即是数据类型的byte数。Imm(rb, ri, s) = Imm + R(rb) + R(ri)`*s。</p>\n<h3 id=\"Data-Movement-Instructions\"><a href=\"#Data-Movement-Instructions\" class=\"headerlink\" title=\"Data Movement Instructions\"></a>Data Movement Instructions</h3><p>MOV &amp; MOVZ &amp; MOVS<br>由mov_ + b/w/l/q 组成，后缀代表的是操作数据的size。一般情况下，MOV指令只会改变寄存器的指定字节数中的值，但是<strong>movl</strong>是一个例外，它操作32-bit int值，但是同时将高32-bit设置为0。<strong>movq</strong>是另一个例外，它只接受32-bit补码表示的值，但是q暗示它处理的是4-word 64-bit的值，所以它会将其sign extend.<strong>movabsq</strong>只能接收一个64-bit立即数，且移动到一个寄存器中。</p>\n<p>MOVZ, MOVS 分别代表将小字节移入大字节时进行zero拓展和符号拓展。</p>\n<h3 id=\"Stack\"><a href=\"#Stack\" class=\"headerlink\" title=\"Stack\"></a>Stack</h3><p>当内存以栈的形式使用时，有两条指令来操作stack data, pushq 等价于 subq $8, %rsp; movq %rbp, (%rsp)。popq 等价于 movq (%rsp), %rax; addq $8, %rsp。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|  高地址  |      |        |</span><br><span class=\"line\">|          |      |        |</span><br><span class=\"line\">|          |增长  |        |</span><br><span class=\"line\">|  低地址  |  ==&gt; |        |</span><br><span class=\"line\">                  |   new  |</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Arithmetic-and-Logical-Operations\"><a href=\"#Arithmetic-and-Logical-Operations\" class=\"headerlink\" title=\"Arithmetic and Logical Operations\"></a>Arithmetic and Logical Operations</h2><p><strong>leaq</strong> S, D  ==&gt;  D &lt;— &amp;S。取S的地址写入D中。如leaq (%rax, %rax, 4), %rax，那么%rax的值被改为地址变量5R(%rax)+7。但是这个指令通常与地址计算无关,而是用来做计算。example:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C code:</span><br><span class=\"line\">long scale(long x, long y, long z)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlong t = x + 4*y + z;</span><br><span class=\"line\">\treturn t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">汇编:</span><br><span class=\"line\"># x in %rdi, y in %rsi, z in %rdx</span><br><span class=\"line\"></span><br><span class=\"line\">leaq (%rdi, %rsi, 4), %rax</span><br><span class=\"line\">leaq (%rdx, %rdx, 2), %rdx</span><br><span class=\"line\">leaq (%rax, %rdx, 4), %rax</span><br><span class=\"line\">ret</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他的一些操作符\"><a href=\"#其他的一些操作符\" class=\"headerlink\" title=\"其他的一些操作符\"></a>其他的一些操作符</h3><p>一元操作指令：incq, decq 分别使stack的最高8个字节自增，自减，也即++,—<br>二元操作指令：addq,subq; addq %rax, %rdx  ==&gt; R(%rdx) += R(%rax); subq %rax, %rdx ==&gt; R(%rdx) -= R(%rax); sarq/shrq salq/shlq 分别为算数/逻辑左移，算数/逻辑右移。二元运算操作符的结果都被第二个参数保存。</p>\n<blockquote>\n<p>Tips : 使用x^x = 0的性质：xorq %rdx, %rdx比 movq $0, %rdx更有效。</p>\n</blockquote>\n<h3 id=\"特殊的一元操作符\"><a href=\"#特殊的一元操作符\" class=\"headerlink\" title=\"特殊的一元操作符\"></a>特殊的一元操作符</h3><p>imulq, mulq, S 将S与R(%rax)相乘得到128-bit,其中的高64-bit存储在%rdx中，低64-bit存储在%rax中。cqto 将SignExtend(R[%rax])的结果以上述形式储存。<br>idivq, divq S 将R[%rdx:%rax]模后的数存储在%rdx中，将商存储在%rax中。一般来说%rdx预先被设置为0。</p>\n<h2 id=\"control\"><a href=\"#control\" class=\"headerlink\" title=\"control\"></a>control</h2><p>两种方式//TODO</p>\n<h3 id=\"Condition-Codes\"><a href=\"#Condition-Codes\" class=\"headerlink\" title=\"Condition Codes\"></a>Condition Codes</h3><p>操作指令完成后一般都alter condition code(leaq 除外)<br>|type|description|<br>|:—-:|:—-|<br>|CF|检测unsigned的overflow|<br>|ZF|检测是否为0|</p>\n<p>可以改变状态码而不用寄存器的两类指令：CMP，TEST。他们都不会改变参数的值。<br>|Instructions|Args|Perform|<br>|:—-:|:—-:|:—-:|<br>|CMP|S1 S2| <strong>S2-S1</strong>|<br>|TEST|S1 S2|S1&amp;S2|</p>\n<h3 id=\"Accessing-the-Condition-Codes\"><a href=\"#Accessing-the-Condition-Codes\" class=\"headerlink\" title=\"Accessing the Condition Codes\"></a>Accessing the Condition Codes</h3><ul>\n<li>通过不同状态码的组合将寄存器的1byte设置为0或1</li>\n<li>通过状态码jump</li>\n<li>有条件地transfer data</li>\n</ul>\n<p>jumps的编码，常用的是PC relative,用编码后的相对地址. 举例如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4003fa : 74 02                                    je  XXXXXX</span><br><span class=\"line\">4003fc : ff d0                                    callq *%rax</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>XXXXXX = 4003fc + 0x02 = 4003fe</p>\n<h2 id=\"Procedures\"><a href=\"#Procedures\" class=\"headerlink\" title=\"Procedures\"></a>Procedures</h2><h2 id=\"Arrary-Allocation-and-Access\"><a href=\"#Arrary-Allocation-and-Access\" class=\"headerlink\" title=\"Arrary Allocation and Access\"></a>Arrary Allocation and Access</h2><h2 id=\"Heterogeneous-Data-Structures\"><a href=\"#Heterogeneous-Data-Structures\" class=\"headerlink\" title=\"Heterogeneous Data Structures\"></a>Heterogeneous Data Structures</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2>"},{"_content":"# bag\n我认为基本的数据模型就只有两种，数组和链表，其他的数据类型都是在这两者上衍生而来的，尤其是链表十分灵活，以下的bag实际上就是用链表实现的，而且是一个后进先出的模型，也就是栈的另一种形式。背包实际上是集合，不在于遍历的顺序，但是要能够遍历。\n\n> 背包是一种不支持从中删除与元素的集合数据类型--它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例可以检查背包否为空或者取背包中元素的数量）迭代的顺序不确定且与用例无关。\n","source":"_posts/bag.md","raw":"# bag\n我认为基本的数据模型就只有两种，数组和链表，其他的数据类型都是在这两者上衍生而来的，尤其是链表十分灵活，以下的bag实际上就是用链表实现的，而且是一个后进先出的模型，也就是栈的另一种形式。背包实际上是集合，不在于遍历的顺序，但是要能够遍历。\n\n> 背包是一种不支持从中删除与元素的集合数据类型--它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例可以检查背包否为空或者取背包中元素的数量）迭代的顺序不确定且与用例无关。\n","slug":"bag","published":1,"date":"2021-08-02T03:14:33.607Z","updated":"2021-08-02T03:14:33.607Z","_id":"ckrsmhqhx0001zhkkhtoyemqq","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"bag\"><a href=\"#bag\" class=\"headerlink\" title=\"bag\"></a>bag</h1><p>我认为基本的数据模型就只有两种，数组和链表，其他的数据类型都是在这两者上衍生而来的，尤其是链表十分灵活，以下的bag实际上就是用链表实现的，而且是一个后进先出的模型，也就是栈的另一种形式。背包实际上是集合，不在于遍历的顺序，但是要能够遍历。</p>\n<blockquote>\n<p>背包是一种不支持从中删除与元素的集合数据类型—它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例可以检查背包否为空或者取背包中元素的数量）迭代的顺序不确定且与用例无关。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"bag\"><a href=\"#bag\" class=\"headerlink\" title=\"bag\"></a>bag</h1><p>我认为基本的数据模型就只有两种，数组和链表，其他的数据类型都是在这两者上衍生而来的，尤其是链表十分灵活，以下的bag实际上就是用链表实现的，而且是一个后进先出的模型，也就是栈的另一种形式。背包实际上是集合，不在于遍历的顺序，但是要能够遍历。</p>\n<blockquote>\n<p>背包是一种不支持从中删除与元素的集合数据类型—它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素（用例可以检查背包否为空或者取背包中元素的数量）迭代的顺序不确定且与用例无关。</p>\n</blockquote>\n"},{"title":"Concurrent Programming","date":"2021-08-11T12:18:44.000Z","_content":"\n\n并发编程\n\n## 多台客户端在迭代服务器模型下的堵塞\n在网络编程一章中，我们接触到了客户端与服务器连接的迭代服务器模型，服务器每次只连接一台客户端，此时另一台客户端向服务器发送请求是会堵塞，那么在连接的pipeline中，这一台客户端究竟堵在了哪一步呢？\n\n- connect 这时客户端的连接请求虽然没有被accept，但服务端已经将它排列在等待队列中\n- writen 数据写入服务端的buffer中\n- read 堵塞在这里！服务端无法向客户端写入。\n\n## 并发服务器\n创建并发服务器有三种方式，Process-based, Event-based, Thread-based。\n\n### Process-based\n\n\n","source":"_posts/Concurrent-Programming.md","raw":"---\ntitle: Concurrent Programming\ndate: 2021-08-11 20:18:44\ntags:\n---\n\n\n并发编程\n\n## 多台客户端在迭代服务器模型下的堵塞\n在网络编程一章中，我们接触到了客户端与服务器连接的迭代服务器模型，服务器每次只连接一台客户端，此时另一台客户端向服务器发送请求是会堵塞，那么在连接的pipeline中，这一台客户端究竟堵在了哪一步呢？\n\n- connect 这时客户端的连接请求虽然没有被accept，但服务端已经将它排列在等待队列中\n- writen 数据写入服务端的buffer中\n- read 堵塞在这里！服务端无法向客户端写入。\n\n## 并发服务器\n创建并发服务器有三种方式，Process-based, Event-based, Thread-based。\n\n### Process-based\n\n\n","slug":"Concurrent-Programming","published":1,"updated":"2021-08-11T15:57:00.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdkek00006ykkcoi40ps7","content":"<p>并发编程</p>\n<h2 id=\"多台客户端在迭代服务器模型下的堵塞\"><a href=\"#多台客户端在迭代服务器模型下的堵塞\" class=\"headerlink\" title=\"多台客户端在迭代服务器模型下的堵塞\"></a>多台客户端在迭代服务器模型下的堵塞</h2><p>在网络编程一章中，我们接触到了客户端与服务器连接的迭代服务器模型，服务器每次只连接一台客户端，此时另一台客户端向服务器发送请求是会堵塞，那么在连接的pipeline中，这一台客户端究竟堵在了哪一步呢？</p>\n<ul>\n<li>connect 这时客户端的连接请求虽然没有被accept，但服务端已经将它排列在等待队列中</li>\n<li>writen 数据写入服务端的buffer中</li>\n<li>read 堵塞在这里！服务端无法向客户端写入。</li>\n</ul>\n<h2 id=\"并发服务器\"><a href=\"#并发服务器\" class=\"headerlink\" title=\"并发服务器\"></a>并发服务器</h2><p>创建并发服务器有三种方式，Process-based, Event-based, Thread-based。</p>\n<h3 id=\"Process-based\"><a href=\"#Process-based\" class=\"headerlink\" title=\"Process-based\"></a>Process-based</h3>","site":{"data":{}},"excerpt":"","more":"<p>并发编程</p>\n<h2 id=\"多台客户端在迭代服务器模型下的堵塞\"><a href=\"#多台客户端在迭代服务器模型下的堵塞\" class=\"headerlink\" title=\"多台客户端在迭代服务器模型下的堵塞\"></a>多台客户端在迭代服务器模型下的堵塞</h2><p>在网络编程一章中，我们接触到了客户端与服务器连接的迭代服务器模型，服务器每次只连接一台客户端，此时另一台客户端向服务器发送请求是会堵塞，那么在连接的pipeline中，这一台客户端究竟堵在了哪一步呢？</p>\n<ul>\n<li>connect 这时客户端的连接请求虽然没有被accept，但服务端已经将它排列在等待队列中</li>\n<li>writen 数据写入服务端的buffer中</li>\n<li>read 堵塞在这里！服务端无法向客户端写入。</li>\n</ul>\n<h2 id=\"并发服务器\"><a href=\"#并发服务器\" class=\"headerlink\" title=\"并发服务器\"></a>并发服务器</h2><p>创建并发服务器有三种方式，Process-based, Event-based, Thread-based。</p>\n<h3 id=\"Process-based\"><a href=\"#Process-based\" class=\"headerlink\" title=\"Process-based\"></a>Process-based</h3>"},{"title":"Exceptional Control Flow","date":"2021-08-11T15:57:54.000Z","_content":"\n# Exceptional Control Flow\n\n机器的一系列指令执行称作control flow,在汇编一章中，我们已经了解了**program state**的change in control flow,例如用Jumps and branches, call and return来改变指令操作的顺序。接下来我们要学习的是**system state**的changes,例如数据在磁盘和内存的运输，keyboard上的Ctrl-C停止等，也就是**exceptional control flow**（异常控制流）的机制。\n\n虽然我们从系统的角度谈异常控制流，但是它同样存在底层和非底层的机制，也就是说它要靠硬件、软件实现。\n\n# Exceptions\nAn exception is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)\n\n## Exception Tables\nEvents组成一个表，当Event k发生时，系统查询索引为k的地址，得到处理异常的程序。\n\n## 同步与异步\n\n### 异步异常(Asynchronous Exceptions)\n异步异常是由外部时间触发的对处理器的操作，也被称为Interrupts。例如没个几个毫秒，外部的timer chip触发一次异常来从用户程序中拿回控制权，在终端输入Ctrl-C等。\n\n### 同步异常(Synchronous Exceptions)\n在执行指令中遇到了相应的Events。\n\n- Traps 人为地设置，如断点调试，系统调用等，结果是返回控制权给下一条指令。\n- Faults 非故意但可恢复或者不可恢复的，如浮点数的异常等，结果是重新执行此条指令或者终止\n- Aborts 非故意且不可恢复的，结果是停止此程序。\n\n## Processes\n**A process is an instatnce of a running program**\n\n一个进程的假象：\n- logical control flow 每个进程似乎独占CPU，由上下文切换实现\n- private address space 似乎都有自己的一块内存空间，由虚拟内存实现\n\n### Concurrent Processes\n并发进程几乎无时无刻不在发生，接下来我们将从上下文切换的角度理解。\n\n我们将process视为一个逻辑控制流，当两个逻辑控制流在时间上重叠时，它们是**并发**的。\n\n首先我们将所有cpu资源视为一个有限的整体（一块CPU），而cpu每次只能执行一个指令，所谓的进程并发其实是cpu在两个逻辑控制流的切换执行。我认为它本质上还是序列的，不过由于这种短时间的切换造成了共同执行的错觉，也就是并发。\n\n上下文切换的细节：将上一个进程的寄存器的值保存在内存中（相当于caller saved?）。上下文切换从代码角度，是一个user code到另一个user code的过渡，而这个过渡由kernel code实现。\n\n\n## Process Control(API)\n从程序员的角度考虑，进程有三种状态，Running, Stopped, Terminated。\n\n### exit \nTerminate the program with status, 正常退出为0，非正常退出返回非0值，exit只会被执行一次，不会return\n\n\n### Fork\nfork函数构建一个子进程，kernel可以在父进程与子进程中上下文切换，也就是并发的。\n\nfork被调用一次，但是会有两个返回值，在父进程中返回子进程号，在子进程中返回0，可以通过返回值来分辨此时在哪个进程中。可以把返回值以链表的形式理解，父进程指向下一个子进程，而子进程如果在链表末端时，则指向NULL也即是0。\n\nfork的返回值很重要，每次必须判断是否成功创建子进程，为了使判断的代码更加compact，所以用Fork重写代码。\n```C\n\nvoid unix_error(char* msg)\n{\n\tfprintf(stderr, \"%s: %s\\n\", msg, strerror(errno));\n\texit(-1);\n}\n\npid_t Fork(void)\n{\n\tpid_t pid;\n\n\tif((pid = fork())<0)\n\t\tunix_error(\"Fork error\");\n\treturn pid;\n}\n```\n\n下面来看一个例子：\n```C\n#include \"csapp.h\"\n\nint main()\n{\n    int x = 1;\n\n    if(Fork() == 0)\n        printf(\"p1: %d\\n\", ++x);\n    printf(\"p2: %d\\n\", --x);\n\n    return 0;\n}\n```\n```bash\n//输出\np2: 0 //父进程\np1: 2 //子进程\np2: 1 //子进程\n```\n首先执行到Fork时，就像薛定谔的猫，进程处于量子叠加态，既是父进程也是子进程。接下来用一个if判断将两者分离。在这个例子中，我们很容易发现，每个进程都有自己变量的拷贝，x互不影响，那么它们的虚拟地址如何呢？\n\n更改代码为输出地址，结果如下。\n\n```bash\np2: 0x7fffd2bc7fe4\np1: 0x7fffd2bc7fe4\np2: 0x7fffd2bc7fe4\n```\n\n可以看到变量的虚拟地址都是相同的，但它们的实际地址不同。\n\n\n### 僵尸进程与wait回收\n\n当子进程结束运行，而父进程没有对其回收的话，子进程沦为僵尸进程，还占用资源。\n\n如果父进程被kill，子进程结束运行，子进程会由**init**回收。\n\n如果父进程结束运行，子进程不终止，那么子进程无法结束、回收。\n\n\n使用wait可以使父进程显示地对子进程回收，父进程会一直suspend直到子进程终止。\n\n\n### execve\n```C\n#include <unistd.h>\n\nint execve(const char *filenaem, const char *argv[],\n\t\t   const char *envp[]);\n\t\t   //Does not return if OK;returns -1 on error\n```\n执行程序(第三个参数直接写入全局变量 environ，由libc决定)\n\n\n\n## Signals\n信号是传送给process的一种信息，可以用于进程间的通信。例如当键盘键入Ctrl+C时，kenerl终止所有foreground的process通过信号SIGINT。总的来说，信号的起作用可以分为两步：sending/delivering　&　receiving\n\n### sending \n\n信号总是由kernel发送的。kernel可以通过某些event的触发自主发送signal，process也可以通过kill函数的调用请求kernel发送signal。\n\n### kill\n```C\n#include <sys/types.h>\n#include <signal.h>\n\nint kill(pid_t pid, int sig);\n```\n\n- pid>0: 发送信号给pid的process\n- pid=0: 发送信号给调用process所在process gruop的所有processes\n- pid<0: 发送信号给pid group为-pid的所有processes\n\n### receiving\n信号的receive是在上下文切换中完成的，也就是从kenel code切换回user code后起作用。\n\n信号发送但是未被received（未被处理时）称为pending。信号在这个阶段起作用靠pending bit vector & blocked bit vector，不同type的信号sent会储存在pending bit vector中，相同type的会被抛弃（该bit已经被置1了）。bloked bit vector则是掩码，设置为1的位置对应信号不会起作用，因为最后信号的处理是由**pending & ~blocked**(unblocked pending signals)决定。\n\n每个信号都有默认的作用，但它们都可以通过signal handler重新设置。\n\n","source":"_posts/Exceptional-Control-Flow.md","raw":"---\ntitle: Exceptional Control Flow\ndate: 2021-08-11 23:57:54\ntags:\n---\n\n# Exceptional Control Flow\n\n机器的一系列指令执行称作control flow,在汇编一章中，我们已经了解了**program state**的change in control flow,例如用Jumps and branches, call and return来改变指令操作的顺序。接下来我们要学习的是**system state**的changes,例如数据在磁盘和内存的运输，keyboard上的Ctrl-C停止等，也就是**exceptional control flow**（异常控制流）的机制。\n\n虽然我们从系统的角度谈异常控制流，但是它同样存在底层和非底层的机制，也就是说它要靠硬件、软件实现。\n\n# Exceptions\nAn exception is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)\n\n## Exception Tables\nEvents组成一个表，当Event k发生时，系统查询索引为k的地址，得到处理异常的程序。\n\n## 同步与异步\n\n### 异步异常(Asynchronous Exceptions)\n异步异常是由外部时间触发的对处理器的操作，也被称为Interrupts。例如没个几个毫秒，外部的timer chip触发一次异常来从用户程序中拿回控制权，在终端输入Ctrl-C等。\n\n### 同步异常(Synchronous Exceptions)\n在执行指令中遇到了相应的Events。\n\n- Traps 人为地设置，如断点调试，系统调用等，结果是返回控制权给下一条指令。\n- Faults 非故意但可恢复或者不可恢复的，如浮点数的异常等，结果是重新执行此条指令或者终止\n- Aborts 非故意且不可恢复的，结果是停止此程序。\n\n## Processes\n**A process is an instatnce of a running program**\n\n一个进程的假象：\n- logical control flow 每个进程似乎独占CPU，由上下文切换实现\n- private address space 似乎都有自己的一块内存空间，由虚拟内存实现\n\n### Concurrent Processes\n并发进程几乎无时无刻不在发生，接下来我们将从上下文切换的角度理解。\n\n我们将process视为一个逻辑控制流，当两个逻辑控制流在时间上重叠时，它们是**并发**的。\n\n首先我们将所有cpu资源视为一个有限的整体（一块CPU），而cpu每次只能执行一个指令，所谓的进程并发其实是cpu在两个逻辑控制流的切换执行。我认为它本质上还是序列的，不过由于这种短时间的切换造成了共同执行的错觉，也就是并发。\n\n上下文切换的细节：将上一个进程的寄存器的值保存在内存中（相当于caller saved?）。上下文切换从代码角度，是一个user code到另一个user code的过渡，而这个过渡由kernel code实现。\n\n\n## Process Control(API)\n从程序员的角度考虑，进程有三种状态，Running, Stopped, Terminated。\n\n### exit \nTerminate the program with status, 正常退出为0，非正常退出返回非0值，exit只会被执行一次，不会return\n\n\n### Fork\nfork函数构建一个子进程，kernel可以在父进程与子进程中上下文切换，也就是并发的。\n\nfork被调用一次，但是会有两个返回值，在父进程中返回子进程号，在子进程中返回0，可以通过返回值来分辨此时在哪个进程中。可以把返回值以链表的形式理解，父进程指向下一个子进程，而子进程如果在链表末端时，则指向NULL也即是0。\n\nfork的返回值很重要，每次必须判断是否成功创建子进程，为了使判断的代码更加compact，所以用Fork重写代码。\n```C\n\nvoid unix_error(char* msg)\n{\n\tfprintf(stderr, \"%s: %s\\n\", msg, strerror(errno));\n\texit(-1);\n}\n\npid_t Fork(void)\n{\n\tpid_t pid;\n\n\tif((pid = fork())<0)\n\t\tunix_error(\"Fork error\");\n\treturn pid;\n}\n```\n\n下面来看一个例子：\n```C\n#include \"csapp.h\"\n\nint main()\n{\n    int x = 1;\n\n    if(Fork() == 0)\n        printf(\"p1: %d\\n\", ++x);\n    printf(\"p2: %d\\n\", --x);\n\n    return 0;\n}\n```\n```bash\n//输出\np2: 0 //父进程\np1: 2 //子进程\np2: 1 //子进程\n```\n首先执行到Fork时，就像薛定谔的猫，进程处于量子叠加态，既是父进程也是子进程。接下来用一个if判断将两者分离。在这个例子中，我们很容易发现，每个进程都有自己变量的拷贝，x互不影响，那么它们的虚拟地址如何呢？\n\n更改代码为输出地址，结果如下。\n\n```bash\np2: 0x7fffd2bc7fe4\np1: 0x7fffd2bc7fe4\np2: 0x7fffd2bc7fe4\n```\n\n可以看到变量的虚拟地址都是相同的，但它们的实际地址不同。\n\n\n### 僵尸进程与wait回收\n\n当子进程结束运行，而父进程没有对其回收的话，子进程沦为僵尸进程，还占用资源。\n\n如果父进程被kill，子进程结束运行，子进程会由**init**回收。\n\n如果父进程结束运行，子进程不终止，那么子进程无法结束、回收。\n\n\n使用wait可以使父进程显示地对子进程回收，父进程会一直suspend直到子进程终止。\n\n\n### execve\n```C\n#include <unistd.h>\n\nint execve(const char *filenaem, const char *argv[],\n\t\t   const char *envp[]);\n\t\t   //Does not return if OK;returns -1 on error\n```\n执行程序(第三个参数直接写入全局变量 environ，由libc决定)\n\n\n\n## Signals\n信号是传送给process的一种信息，可以用于进程间的通信。例如当键盘键入Ctrl+C时，kenerl终止所有foreground的process通过信号SIGINT。总的来说，信号的起作用可以分为两步：sending/delivering　&　receiving\n\n### sending \n\n信号总是由kernel发送的。kernel可以通过某些event的触发自主发送signal，process也可以通过kill函数的调用请求kernel发送signal。\n\n### kill\n```C\n#include <sys/types.h>\n#include <signal.h>\n\nint kill(pid_t pid, int sig);\n```\n\n- pid>0: 发送信号给pid的process\n- pid=0: 发送信号给调用process所在process gruop的所有processes\n- pid<0: 发送信号给pid group为-pid的所有processes\n\n### receiving\n信号的receive是在上下文切换中完成的，也就是从kenel code切换回user code后起作用。\n\n信号发送但是未被received（未被处理时）称为pending。信号在这个阶段起作用靠pending bit vector & blocked bit vector，不同type的信号sent会储存在pending bit vector中，相同type的会被抛弃（该bit已经被置1了）。bloked bit vector则是掩码，设置为1的位置对应信号不会起作用，因为最后信号的处理是由**pending & ~blocked**(unblocked pending signals)决定。\n\n每个信号都有默认的作用，但它们都可以通过signal handler重新设置。\n\n","slug":"Exceptional-Control-Flow","published":1,"updated":"2021-08-13T14:26:53.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdkel00016ykk9phv3rgn","content":"<h1 id=\"Exceptional-Control-Flow\"><a href=\"#Exceptional-Control-Flow\" class=\"headerlink\" title=\"Exceptional Control Flow\"></a>Exceptional Control Flow</h1><p>机器的一系列指令执行称作control flow,在汇编一章中，我们已经了解了<strong>program state</strong>的change in control flow,例如用Jumps and branches, call and return来改变指令操作的顺序。接下来我们要学习的是<strong>system state</strong>的changes,例如数据在磁盘和内存的运输，keyboard上的Ctrl-C停止等，也就是<strong>exceptional control flow</strong>（异常控制流）的机制。</p>\n<p>虽然我们从系统的角度谈异常控制流，但是它同样存在底层和非底层的机制，也就是说它要靠硬件、软件实现。</p>\n<h1 id=\"Exceptions\"><a href=\"#Exceptions\" class=\"headerlink\" title=\"Exceptions\"></a>Exceptions</h1><p>An exception is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)</p>\n<h2 id=\"Exception-Tables\"><a href=\"#Exception-Tables\" class=\"headerlink\" title=\"Exception Tables\"></a>Exception Tables</h2><p>Events组成一个表，当Event k发生时，系统查询索引为k的地址，得到处理异常的程序。</p>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><h3 id=\"异步异常-Asynchronous-Exceptions\"><a href=\"#异步异常-Asynchronous-Exceptions\" class=\"headerlink\" title=\"异步异常(Asynchronous Exceptions)\"></a>异步异常(Asynchronous Exceptions)</h3><p>异步异常是由外部时间触发的对处理器的操作，也被称为Interrupts。例如没个几个毫秒，外部的timer chip触发一次异常来从用户程序中拿回控制权，在终端输入Ctrl-C等。</p>\n<h3 id=\"同步异常-Synchronous-Exceptions\"><a href=\"#同步异常-Synchronous-Exceptions\" class=\"headerlink\" title=\"同步异常(Synchronous Exceptions)\"></a>同步异常(Synchronous Exceptions)</h3><p>在执行指令中遇到了相应的Events。</p>\n<ul>\n<li>Traps 人为地设置，如断点调试，系统调用等，结果是返回控制权给下一条指令。</li>\n<li>Faults 非故意但可恢复或者不可恢复的，如浮点数的异常等，结果是重新执行此条指令或者终止</li>\n<li>Aborts 非故意且不可恢复的，结果是停止此程序。</li>\n</ul>\n<h2 id=\"Processes\"><a href=\"#Processes\" class=\"headerlink\" title=\"Processes\"></a>Processes</h2><p><strong>A process is an instatnce of a running program</strong></p>\n<p>一个进程的假象：</p>\n<ul>\n<li>logical control flow 每个进程似乎独占CPU，由上下文切换实现</li>\n<li>private address space 似乎都有自己的一块内存空间，由虚拟内存实现</li>\n</ul>\n<h3 id=\"Concurrent-Processes\"><a href=\"#Concurrent-Processes\" class=\"headerlink\" title=\"Concurrent Processes\"></a>Concurrent Processes</h3><p>并发进程几乎无时无刻不在发生，接下来我们将从上下文切换的角度理解。</p>\n<p>我们将process视为一个逻辑控制流，当两个逻辑控制流在时间上重叠时，它们是<strong>并发</strong>的。</p>\n<p>首先我们将所有cpu资源视为一个有限的整体（一块CPU），而cpu每次只能执行一个指令，所谓的进程并发其实是cpu在两个逻辑控制流的切换执行。我认为它本质上还是序列的，不过由于这种短时间的切换造成了共同执行的错觉，也就是并发。</p>\n<p>上下文切换的细节：将上一个进程的寄存器的值保存在内存中（相当于caller saved?）。上下文切换从代码角度，是一个user code到另一个user code的过渡，而这个过渡由kernel code实现。</p>\n<h2 id=\"Process-Control-API\"><a href=\"#Process-Control-API\" class=\"headerlink\" title=\"Process Control(API)\"></a>Process Control(API)</h2><p>从程序员的角度考虑，进程有三种状态，Running, Stopped, Terminated。</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p>Terminate the program with status, 正常退出为0，非正常退出返回非0值，exit只会被执行一次，不会return</p>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><p>fork函数构建一个子进程，kernel可以在父进程与子进程中上下文切换，也就是并发的。</p>\n<p>fork被调用一次，但是会有两个返回值，在父进程中返回子进程号，在子进程中返回0，可以通过返回值来分辨此时在哪个进程中。可以把返回值以链表的形式理解，父进程指向下一个子进程，而子进程如果在链表末端时，则指向NULL也即是0。</p>\n<p>fork的返回值很重要，每次必须判断是否成功创建子进程，为了使判断的代码更加compact，所以用Fork重写代码。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unix_error</span><span class=\"params\">(<span class=\"keyword\">char</span>* msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;%s: %s\\n&quot;</span>, msg, strerror(errno));</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">Fork</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((pid = fork())&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tunix_error(<span class=\"string\">&quot;Fork error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面来看一个例子：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;csapp.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Fork() == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;p1: %d\\n&quot;</span>, ++x);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;p2: %d\\n&quot;</span>, --x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//输出</span><br><span class=\"line\">p2: 0 //父进程</span><br><span class=\"line\">p1: 2 //子进程</span><br><span class=\"line\">p2: 1 //子进程</span><br></pre></td></tr></table></figure><br>首先执行到Fork时，就像薛定谔的猫，进程处于量子叠加态，既是父进程也是子进程。接下来用一个if判断将两者分离。在这个例子中，我们很容易发现，每个进程都有自己变量的拷贝，x互不影响，那么它们的虚拟地址如何呢？</p>\n<p>更改代码为输出地址，结果如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p2: 0x7fffd2bc7fe4</span><br><span class=\"line\">p1: 0x7fffd2bc7fe4</span><br><span class=\"line\">p2: 0x7fffd2bc7fe4</span><br></pre></td></tr></table></figure>\n<p>可以看到变量的虚拟地址都是相同的，但它们的实际地址不同。</p>\n<h3 id=\"僵尸进程与wait回收\"><a href=\"#僵尸进程与wait回收\" class=\"headerlink\" title=\"僵尸进程与wait回收\"></a>僵尸进程与wait回收</h3><p>当子进程结束运行，而父进程没有对其回收的话，子进程沦为僵尸进程，还占用资源。</p>\n<p>如果父进程被kill，子进程结束运行，子进程会由<strong>init</strong>回收。</p>\n<p>如果父进程结束运行，子进程不终止，那么子进程无法结束、回收。</p>\n<p>使用wait可以使父进程显示地对子进程回收，父进程会一直suspend直到子进程终止。</p>\n<h3 id=\"execve\"><a href=\"#execve\" class=\"headerlink\" title=\"execve\"></a>execve</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filenaem, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *argv[],</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *envp[])</span></span>;</span><br><span class=\"line\">\t\t   <span class=\"comment\">//Does not return if OK;returns -1 on error</span></span><br></pre></td></tr></table></figure>\n<p>执行程序(第三个参数直接写入全局变量 environ，由libc决定)</p>\n<h2 id=\"Signals\"><a href=\"#Signals\" class=\"headerlink\" title=\"Signals\"></a>Signals</h2><p>信号是传送给process的一种信息，可以用于进程间的通信。例如当键盘键入Ctrl+C时，kenerl终止所有foreground的process通过信号SIGINT。总的来说，信号的起作用可以分为两步：sending/delivering　&amp;　receiving</p>\n<h3 id=\"sending\"><a href=\"#sending\" class=\"headerlink\" title=\"sending\"></a>sending</h3><p>信号总是由kernel发送的。kernel可以通过某些event的触发自主发送signal，process也可以通过kill函数的调用请求kernel发送signal。</p>\n<h3 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>pid&gt;0: 发送信号给pid的process</li>\n<li>pid=0: 发送信号给调用process所在process gruop的所有processes</li>\n<li>pid&lt;0: 发送信号给pid group为-pid的所有processes</li>\n</ul>\n<h3 id=\"receiving\"><a href=\"#receiving\" class=\"headerlink\" title=\"receiving\"></a>receiving</h3><p>信号的receive是在上下文切换中完成的，也就是从kenel code切换回user code后起作用。</p>\n<p>信号发送但是未被received（未被处理时）称为pending。信号在这个阶段起作用靠pending bit vector &amp; blocked bit vector，不同type的信号sent会储存在pending bit vector中，相同type的会被抛弃（该bit已经被置1了）。bloked bit vector则是掩码，设置为1的位置对应信号不会起作用，因为最后信号的处理是由<strong>pending &amp; ~blocked</strong>(unblocked pending signals)决定。</p>\n<p>每个信号都有默认的作用，但它们都可以通过signal handler重新设置。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Exceptional-Control-Flow\"><a href=\"#Exceptional-Control-Flow\" class=\"headerlink\" title=\"Exceptional Control Flow\"></a>Exceptional Control Flow</h1><p>机器的一系列指令执行称作control flow,在汇编一章中，我们已经了解了<strong>program state</strong>的change in control flow,例如用Jumps and branches, call and return来改变指令操作的顺序。接下来我们要学习的是<strong>system state</strong>的changes,例如数据在磁盘和内存的运输，keyboard上的Ctrl-C停止等，也就是<strong>exceptional control flow</strong>（异常控制流）的机制。</p>\n<p>虽然我们从系统的角度谈异常控制流，但是它同样存在底层和非底层的机制，也就是说它要靠硬件、软件实现。</p>\n<h1 id=\"Exceptions\"><a href=\"#Exceptions\" class=\"headerlink\" title=\"Exceptions\"></a>Exceptions</h1><p>An exception is a transfer of control to the OS kernel in response to some event (i.e., change in processor state)</p>\n<h2 id=\"Exception-Tables\"><a href=\"#Exception-Tables\" class=\"headerlink\" title=\"Exception Tables\"></a>Exception Tables</h2><p>Events组成一个表，当Event k发生时，系统查询索引为k的地址，得到处理异常的程序。</p>\n<h2 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h2><h3 id=\"异步异常-Asynchronous-Exceptions\"><a href=\"#异步异常-Asynchronous-Exceptions\" class=\"headerlink\" title=\"异步异常(Asynchronous Exceptions)\"></a>异步异常(Asynchronous Exceptions)</h3><p>异步异常是由外部时间触发的对处理器的操作，也被称为Interrupts。例如没个几个毫秒，外部的timer chip触发一次异常来从用户程序中拿回控制权，在终端输入Ctrl-C等。</p>\n<h3 id=\"同步异常-Synchronous-Exceptions\"><a href=\"#同步异常-Synchronous-Exceptions\" class=\"headerlink\" title=\"同步异常(Synchronous Exceptions)\"></a>同步异常(Synchronous Exceptions)</h3><p>在执行指令中遇到了相应的Events。</p>\n<ul>\n<li>Traps 人为地设置，如断点调试，系统调用等，结果是返回控制权给下一条指令。</li>\n<li>Faults 非故意但可恢复或者不可恢复的，如浮点数的异常等，结果是重新执行此条指令或者终止</li>\n<li>Aborts 非故意且不可恢复的，结果是停止此程序。</li>\n</ul>\n<h2 id=\"Processes\"><a href=\"#Processes\" class=\"headerlink\" title=\"Processes\"></a>Processes</h2><p><strong>A process is an instatnce of a running program</strong></p>\n<p>一个进程的假象：</p>\n<ul>\n<li>logical control flow 每个进程似乎独占CPU，由上下文切换实现</li>\n<li>private address space 似乎都有自己的一块内存空间，由虚拟内存实现</li>\n</ul>\n<h3 id=\"Concurrent-Processes\"><a href=\"#Concurrent-Processes\" class=\"headerlink\" title=\"Concurrent Processes\"></a>Concurrent Processes</h3><p>并发进程几乎无时无刻不在发生，接下来我们将从上下文切换的角度理解。</p>\n<p>我们将process视为一个逻辑控制流，当两个逻辑控制流在时间上重叠时，它们是<strong>并发</strong>的。</p>\n<p>首先我们将所有cpu资源视为一个有限的整体（一块CPU），而cpu每次只能执行一个指令，所谓的进程并发其实是cpu在两个逻辑控制流的切换执行。我认为它本质上还是序列的，不过由于这种短时间的切换造成了共同执行的错觉，也就是并发。</p>\n<p>上下文切换的细节：将上一个进程的寄存器的值保存在内存中（相当于caller saved?）。上下文切换从代码角度，是一个user code到另一个user code的过渡，而这个过渡由kernel code实现。</p>\n<h2 id=\"Process-Control-API\"><a href=\"#Process-Control-API\" class=\"headerlink\" title=\"Process Control(API)\"></a>Process Control(API)</h2><p>从程序员的角度考虑，进程有三种状态，Running, Stopped, Terminated。</p>\n<h3 id=\"exit\"><a href=\"#exit\" class=\"headerlink\" title=\"exit\"></a>exit</h3><p>Terminate the program with status, 正常退出为0，非正常退出返回非0值，exit只会被执行一次，不会return</p>\n<h3 id=\"Fork\"><a href=\"#Fork\" class=\"headerlink\" title=\"Fork\"></a>Fork</h3><p>fork函数构建一个子进程，kernel可以在父进程与子进程中上下文切换，也就是并发的。</p>\n<p>fork被调用一次，但是会有两个返回值，在父进程中返回子进程号，在子进程中返回0，可以通过返回值来分辨此时在哪个进程中。可以把返回值以链表的形式理解，父进程指向下一个子进程，而子进程如果在链表末端时，则指向NULL也即是0。</p>\n<p>fork的返回值很重要，每次必须判断是否成功创建子进程，为了使判断的代码更加compact，所以用Fork重写代码。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unix_error</span><span class=\"params\">(<span class=\"keyword\">char</span>* msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;%s: %s\\n&quot;</span>, msg, strerror(errno));</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">Fork</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>((pid = fork())&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tunix_error(<span class=\"string\">&quot;Fork error&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面来看一个例子：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;csapp.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Fork() == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;p1: %d\\n&quot;</span>, ++x);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;p2: %d\\n&quot;</span>, --x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//输出</span><br><span class=\"line\">p2: 0 //父进程</span><br><span class=\"line\">p1: 2 //子进程</span><br><span class=\"line\">p2: 1 //子进程</span><br></pre></td></tr></table></figure><br>首先执行到Fork时，就像薛定谔的猫，进程处于量子叠加态，既是父进程也是子进程。接下来用一个if判断将两者分离。在这个例子中，我们很容易发现，每个进程都有自己变量的拷贝，x互不影响，那么它们的虚拟地址如何呢？</p>\n<p>更改代码为输出地址，结果如下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p2: 0x7fffd2bc7fe4</span><br><span class=\"line\">p1: 0x7fffd2bc7fe4</span><br><span class=\"line\">p2: 0x7fffd2bc7fe4</span><br></pre></td></tr></table></figure>\n<p>可以看到变量的虚拟地址都是相同的，但它们的实际地址不同。</p>\n<h3 id=\"僵尸进程与wait回收\"><a href=\"#僵尸进程与wait回收\" class=\"headerlink\" title=\"僵尸进程与wait回收\"></a>僵尸进程与wait回收</h3><p>当子进程结束运行，而父进程没有对其回收的话，子进程沦为僵尸进程，还占用资源。</p>\n<p>如果父进程被kill，子进程结束运行，子进程会由<strong>init</strong>回收。</p>\n<p>如果父进程结束运行，子进程不终止，那么子进程无法结束、回收。</p>\n<p>使用wait可以使父进程显示地对子进程回收，父进程会一直suspend直到子进程终止。</p>\n<h3 id=\"execve\"><a href=\"#execve\" class=\"headerlink\" title=\"execve\"></a>execve</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *filenaem, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *argv[],</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t\t   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *envp[])</span></span>;</span><br><span class=\"line\">\t\t   <span class=\"comment\">//Does not return if OK;returns -1 on error</span></span><br></pre></td></tr></table></figure>\n<p>执行程序(第三个参数直接写入全局变量 environ，由libc决定)</p>\n<h2 id=\"Signals\"><a href=\"#Signals\" class=\"headerlink\" title=\"Signals\"></a>Signals</h2><p>信号是传送给process的一种信息，可以用于进程间的通信。例如当键盘键入Ctrl+C时，kenerl终止所有foreground的process通过信号SIGINT。总的来说，信号的起作用可以分为两步：sending/delivering　&amp;　receiving</p>\n<h3 id=\"sending\"><a href=\"#sending\" class=\"headerlink\" title=\"sending\"></a>sending</h3><p>信号总是由kernel发送的。kernel可以通过某些event的触发自主发送signal，process也可以通过kill函数的调用请求kernel发送signal。</p>\n<h3 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>pid&gt;0: 发送信号给pid的process</li>\n<li>pid=0: 发送信号给调用process所在process gruop的所有processes</li>\n<li>pid&lt;0: 发送信号给pid group为-pid的所有processes</li>\n</ul>\n<h3 id=\"receiving\"><a href=\"#receiving\" class=\"headerlink\" title=\"receiving\"></a>receiving</h3><p>信号的receive是在上下文切换中完成的，也就是从kenel code切换回user code后起作用。</p>\n<p>信号发送但是未被received（未被处理时）称为pending。信号在这个阶段起作用靠pending bit vector &amp; blocked bit vector，不同type的信号sent会储存在pending bit vector中，相同type的会被抛弃（该bit已经被置1了）。bloked bit vector则是掩码，设置为1的位置对应信号不会起作用，因为最后信号的处理是由<strong>pending &amp; ~blocked</strong>(unblocked pending signals)决定。</p>\n<p>每个信号都有默认的作用，但它们都可以通过signal handler重新设置。</p>\n"},{"title":"Network Programming","date":"2021-08-02T03:15:32.000Z","mathjax":true,"_content":"\n# The Client-Server Programming Model\n\n**transaction**\n\n\n```\n---------------                                              ------------------\n|    Client    |  ------1. Client sends request----------->  |     Server     |                           ---------------\n|    Process   |                                             |     Process    |   <--2.Server process--> |    Resource   |\n----------------  <-----3. Server sends respose------------  ------------------                           ---------------\n4. Client processes reponse\n```\n\n**clients and servers are processes and not machines, or hosts**\n\nA single host can run many different clients and servers concurrently（并发地）. And a client and server transaction can be on tne same or different hosts. \n\n\n\n# Web Servers\nHTTP 是client与server交互的协议。\n\n## Content\nContent是通过HTTP传输的内容，有html. plain. postcript. gif, pang, jpeg等多种类型，通过servers提供content的方式又可以分为serving static conten, serving dynamic content。\n传输的文件都有一个独特的名字URL（universal resource locator）以http://www.google.com:80/index.html为例,client用前缀http:/www.google.com:80决定联系的服务器，服务器位置以及listening的port。servers 用/index.html寻找文件并判断它是动态资源还是静态资源。\n","source":"_posts/Network-Programming.md","raw":"---\ntitle: Network Programming\ndate: 2021-08-02 11:15:32\ntags:\nmathjax: true\n---\n\n# The Client-Server Programming Model\n\n**transaction**\n\n\n```\n---------------                                              ------------------\n|    Client    |  ------1. Client sends request----------->  |     Server     |                           ---------------\n|    Process   |                                             |     Process    |   <--2.Server process--> |    Resource   |\n----------------  <-----3. Server sends respose------------  ------------------                           ---------------\n4. Client processes reponse\n```\n\n**clients and servers are processes and not machines, or hosts**\n\nA single host can run many different clients and servers concurrently（并发地）. And a client and server transaction can be on tne same or different hosts. \n\n\n\n# Web Servers\nHTTP 是client与server交互的协议。\n\n## Content\nContent是通过HTTP传输的内容，有html. plain. postcript. gif, pang, jpeg等多种类型，通过servers提供content的方式又可以分为serving static conten, serving dynamic content。\n传输的文件都有一个独特的名字URL（universal resource locator）以http://www.google.com:80/index.html为例,client用前缀http:/www.google.com:80决定联系的服务器，服务器位置以及listening的port。servers 用/index.html寻找文件并判断它是动态资源还是静态资源。\n","slug":"Network-Programming","published":1,"updated":"2021-08-03T09:24:20.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdken00026ykk3nhmdcow","content":"<h1 id=\"The-Client-Server-Programming-Model\"><a href=\"#The-Client-Server-Programming-Model\" class=\"headerlink\" title=\"The Client-Server Programming Model\"></a>The Client-Server Programming Model</h1><p><strong>transaction</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------                                              ------------------</span><br><span class=\"line\">|    Client    |  ------1. Client sends request-----------&gt;  |     Server     |                           ---------------</span><br><span class=\"line\">|    Process   |                                             |     Process    |   &lt;--2.Server process--&gt; |    Resource   |</span><br><span class=\"line\">----------------  &lt;-----3. Server sends respose------------  ------------------                           ---------------</span><br><span class=\"line\">4. Client processes reponse</span><br></pre></td></tr></table></figure>\n<p><strong>clients and servers are processes and not machines, or hosts</strong></p>\n<p>A single host can run many different clients and servers concurrently（并发地）. And a client and server transaction can be on tne same or different hosts. </p>\n<h1 id=\"Web-Servers\"><a href=\"#Web-Servers\" class=\"headerlink\" title=\"Web Servers\"></a>Web Servers</h1><p>HTTP 是client与server交互的协议。</p>\n<h2 id=\"Content\"><a href=\"#Content\" class=\"headerlink\" title=\"Content\"></a>Content</h2><p>Content是通过HTTP传输的内容，有html. plain. postcript. gif, pang, jpeg等多种类型，通过servers提供content的方式又可以分为serving static conten, serving dynamic content。<br>传输的文件都有一个独特的名字URL（universal resource locator）以<a href=\"http://www.google.com:80/index.html为例,client用前缀http:/www.google.com:80决定联系的服务器，服务器位置以及listening的port。servers\">http://www.google.com:80/index.html为例,client用前缀http:/www.google.com:80决定联系的服务器，服务器位置以及listening的port。servers</a> 用/index.html寻找文件并判断它是动态资源还是静态资源。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"The-Client-Server-Programming-Model\"><a href=\"#The-Client-Server-Programming-Model\" class=\"headerlink\" title=\"The Client-Server Programming Model\"></a>The Client-Server Programming Model</h1><p><strong>transaction</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------------                                              ------------------</span><br><span class=\"line\">|    Client    |  ------1. Client sends request-----------&gt;  |     Server     |                           ---------------</span><br><span class=\"line\">|    Process   |                                             |     Process    |   &lt;--2.Server process--&gt; |    Resource   |</span><br><span class=\"line\">----------------  &lt;-----3. Server sends respose------------  ------------------                           ---------------</span><br><span class=\"line\">4. Client processes reponse</span><br></pre></td></tr></table></figure>\n<p><strong>clients and servers are processes and not machines, or hosts</strong></p>\n<p>A single host can run many different clients and servers concurrently（并发地）. And a client and server transaction can be on tne same or different hosts. </p>\n<h1 id=\"Web-Servers\"><a href=\"#Web-Servers\" class=\"headerlink\" title=\"Web Servers\"></a>Web Servers</h1><p>HTTP 是client与server交互的协议。</p>\n<h2 id=\"Content\"><a href=\"#Content\" class=\"headerlink\" title=\"Content\"></a>Content</h2><p>Content是通过HTTP传输的内容，有html. plain. postcript. gif, pang, jpeg等多种类型，通过servers提供content的方式又可以分为serving static conten, serving dynamic content。<br>传输的文件都有一个独特的名字URL（universal resource locator）以<a href=\"http://www.google.com:80/index.html为例,client用前缀http:/www.google.com:80决定联系的服务器，服务器位置以及listening的port。servers\">http://www.google.com:80/index.html为例,client用前缀http:/www.google.com:80决定联系的服务器，服务器位置以及listening的port。servers</a> 用/index.html寻找文件并判断它是动态资源还是静态资源。</p>\n"},{"title":"Pytorch Dataloader","date":"2021-08-10T02:32:41.000Z","_content":"\n# Pytorch DataLoader\nDataLoader是pytorch中的一个高级的迭代器，支持\n- Batching the data\n- Shuffling the data\n- Load the data in parallel using multiprocessing workers\n\n使用时需要继承torch.utils.dadta.Dataset类，并重写函数：\n- **__len__** 返回数据集的总量\n- **__getitem__** 通过索引访问数据\n\n\n","source":"_posts/Pytorch-Dataloader.md","raw":"---\ntitle: Pytorch Dataloader\ndate: 2021-08-10 10:32:41\ntags:\n---\n\n# Pytorch DataLoader\nDataLoader是pytorch中的一个高级的迭代器，支持\n- Batching the data\n- Shuffling the data\n- Load the data in parallel using multiprocessing workers\n\n使用时需要继承torch.utils.dadta.Dataset类，并重写函数：\n- **__len__** 返回数据集的总量\n- **__getitem__** 通过索引访问数据\n\n\n","slug":"Pytorch-Dataloader","published":1,"updated":"2021-08-10T14:00:36.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdken00036ykk58he9jm6","content":"<h1 id=\"Pytorch-DataLoader\"><a href=\"#Pytorch-DataLoader\" class=\"headerlink\" title=\"Pytorch DataLoader\"></a>Pytorch DataLoader</h1><p>DataLoader是pytorch中的一个高级的迭代器，支持</p>\n<ul>\n<li>Batching the data</li>\n<li>Shuffling the data</li>\n<li>Load the data in parallel using multiprocessing workers</li>\n</ul>\n<p>使用时需要继承torch.utils.dadta.Dataset类，并重写函数：</p>\n<ul>\n<li><strong><strong>len</strong></strong> 返回数据集的总量</li>\n<li><strong><strong>getitem</strong></strong> 通过索引访问数据</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Pytorch-DataLoader\"><a href=\"#Pytorch-DataLoader\" class=\"headerlink\" title=\"Pytorch DataLoader\"></a>Pytorch DataLoader</h1><p>DataLoader是pytorch中的一个高级的迭代器，支持</p>\n<ul>\n<li>Batching the data</li>\n<li>Shuffling the data</li>\n<li>Load the data in parallel using multiprocessing workers</li>\n</ul>\n<p>使用时需要继承torch.utils.dadta.Dataset类，并重写函数：</p>\n<ul>\n<li><strong><strong>len</strong></strong> 返回数据集的总量</li>\n<li><strong><strong>getitem</strong></strong> 通过索引访问数据</li>\n</ul>\n"},{"title":"Pytorch Embedding","date":"2021-08-10T02:46:30.000Z","_content":"\n# Pytroch Embedding\n\n## Encodings One-Hot\n\n","source":"_posts/Pytorch-Embedding.md","raw":"---\ntitle: Pytorch Embedding\ndate: 2021-08-10 10:46:30\ntags:\n---\n\n# Pytroch Embedding\n\n## Encodings One-Hot\n\n","slug":"Pytorch-Embedding","published":1,"updated":"2021-08-10T02:47:25.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdkep00046ykk1qsz0f1c","content":"<h1 id=\"Pytroch-Embedding\"><a href=\"#Pytroch-Embedding\" class=\"headerlink\" title=\"Pytroch Embedding\"></a>Pytroch Embedding</h1><h2 id=\"Encodings-One-Hot\"><a href=\"#Encodings-One-Hot\" class=\"headerlink\" title=\"Encodings One-Hot\"></a>Encodings One-Hot</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Pytroch-Embedding\"><a href=\"#Pytroch-Embedding\" class=\"headerlink\" title=\"Pytroch Embedding\"></a>Pytroch Embedding</h1><h2 id=\"Encodings-One-Hot\"><a href=\"#Encodings-One-Hot\" class=\"headerlink\" title=\"Encodings One-Hot\"></a>Encodings One-Hot</h2>"},{"title":"System Level I/O","date":"2021-08-10T13:28:15.000Z","_content":"\n\n# System Level I/O\n\n## Unix I/O\n\n在Unix系统中，一切对象都是**文件**。而文件只是一组字节序列。甚至连接到系统的设备，Socket都视为文件。\n\n文件的分类\n- Regular file: Contains arbitrary data\n- Directory: Index for a related group of files\n- Socket: For communicating with a process on another machine\n- Named pipes(管道)\n- Symbolic links\n- Character and block decvices\n\n> seek 指示文件读到的位置\n\n### Regula files \n> C语言标准库中的API将常规文件分为text file, binary file。Linux/MAC 用'\\n', '\\r\\n'\n\n### Directories\n一组links组成了目录文件，每一个link是文件名到文件的映射。\n\n## Open Files\n\n### **File Descriptor**\n文件操作符，一个小的整数，标识打开的文件。\n> 文件操作符也是函数返回值，每次系统调用时都应该检查返回值\n\n## Close Files\nclose(fd)\n\n> 关闭文件时也是可能出错的，多线程时共享内存的情况，所以也应该检查返回值\n\n## Reading Files & Writing Files\n需要文件描述符fd和指向buffer的指针及其大小。\n> Tips : strace 可以检查程序的系统级调用。\n读写文件时，当字节数大于1小于最大值时，称作Short Counts,发生在以下三种情况\n\n- 遇到EOF\n- 在终端读入时遇到换行符\n- 读写networks sockets\n\n不会发生Short Counts的情况\n- 从disk读入\n- 向disk写入\n\n## RIO\nRIO是健壮的I/O包，在Socket中非常有用。RIO提供了非缓存和缓存的两类函数。\n> Buffered RIO are thread-safe\n\n### Unbuffered\n循环读入每一个字节，根据返回值进行讨论\n\n### Buffered\n先读入一段字节到缓冲区，通过指针访问读入字节，避免了重复调用系统的I/O函数，提高了效率。\n\n\n## Unix Kernel 中的文件表示\n//TODO\n\n### Fiel Metadata （文件元数据）\n描述文件信息的数据，它们存放在结构体stat中。这些数据描述了文件是否可读，文件类型等基本信息。\n\n\n### sharing\n\n### 重定向\n\n\n## Standard I/O\nStandard I/O 指的其实就是Ｃ语言中常见的I/O函数，如scanf,fscanf,printf,它们都是待缓冲的I/O。\n\n> Standard I/O 常用于终端文件读写，而RIO常用于网络编程。\n\n\n\n\n","source":"_posts/System-Level-I-O.md","raw":"---\ntitle: System Level I/O\ndate: 2021-08-10 21:28:15\ntags:\n---\n\n\n# System Level I/O\n\n## Unix I/O\n\n在Unix系统中，一切对象都是**文件**。而文件只是一组字节序列。甚至连接到系统的设备，Socket都视为文件。\n\n文件的分类\n- Regular file: Contains arbitrary data\n- Directory: Index for a related group of files\n- Socket: For communicating with a process on another machine\n- Named pipes(管道)\n- Symbolic links\n- Character and block decvices\n\n> seek 指示文件读到的位置\n\n### Regula files \n> C语言标准库中的API将常规文件分为text file, binary file。Linux/MAC 用'\\n', '\\r\\n'\n\n### Directories\n一组links组成了目录文件，每一个link是文件名到文件的映射。\n\n## Open Files\n\n### **File Descriptor**\n文件操作符，一个小的整数，标识打开的文件。\n> 文件操作符也是函数返回值，每次系统调用时都应该检查返回值\n\n## Close Files\nclose(fd)\n\n> 关闭文件时也是可能出错的，多线程时共享内存的情况，所以也应该检查返回值\n\n## Reading Files & Writing Files\n需要文件描述符fd和指向buffer的指针及其大小。\n> Tips : strace 可以检查程序的系统级调用。\n读写文件时，当字节数大于1小于最大值时，称作Short Counts,发生在以下三种情况\n\n- 遇到EOF\n- 在终端读入时遇到换行符\n- 读写networks sockets\n\n不会发生Short Counts的情况\n- 从disk读入\n- 向disk写入\n\n## RIO\nRIO是健壮的I/O包，在Socket中非常有用。RIO提供了非缓存和缓存的两类函数。\n> Buffered RIO are thread-safe\n\n### Unbuffered\n循环读入每一个字节，根据返回值进行讨论\n\n### Buffered\n先读入一段字节到缓冲区，通过指针访问读入字节，避免了重复调用系统的I/O函数，提高了效率。\n\n\n## Unix Kernel 中的文件表示\n//TODO\n\n### Fiel Metadata （文件元数据）\n描述文件信息的数据，它们存放在结构体stat中。这些数据描述了文件是否可读，文件类型等基本信息。\n\n\n### sharing\n\n### 重定向\n\n\n## Standard I/O\nStandard I/O 指的其实就是Ｃ语言中常见的I/O函数，如scanf,fscanf,printf,它们都是待缓冲的I/O。\n\n> Standard I/O 常用于终端文件读写，而RIO常用于网络编程。\n\n\n\n\n","slug":"System-Level-I-O","published":1,"updated":"2021-08-11T02:18:19.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdkeq00056ykkdus75amu","content":"<h1 id=\"System-Level-I-O\"><a href=\"#System-Level-I-O\" class=\"headerlink\" title=\"System Level I/O\"></a>System Level I/O</h1><h2 id=\"Unix-I-O\"><a href=\"#Unix-I-O\" class=\"headerlink\" title=\"Unix I/O\"></a>Unix I/O</h2><p>在Unix系统中，一切对象都是<strong>文件</strong>。而文件只是一组字节序列。甚至连接到系统的设备，Socket都视为文件。</p>\n<p>文件的分类</p>\n<ul>\n<li>Regular file: Contains arbitrary data</li>\n<li>Directory: Index for a related group of files</li>\n<li>Socket: For communicating with a process on another machine</li>\n<li>Named pipes(管道)</li>\n<li>Symbolic links</li>\n<li>Character and block decvices</li>\n</ul>\n<blockquote>\n<p>seek 指示文件读到的位置</p>\n</blockquote>\n<h3 id=\"Regula-files\"><a href=\"#Regula-files\" class=\"headerlink\" title=\"Regula files\"></a>Regula files</h3><blockquote>\n<p>C语言标准库中的API将常规文件分为text file, binary file。Linux/MAC 用’\\n’, ‘\\r\\n’</p>\n</blockquote>\n<h3 id=\"Directories\"><a href=\"#Directories\" class=\"headerlink\" title=\"Directories\"></a>Directories</h3><p>一组links组成了目录文件，每一个link是文件名到文件的映射。</p>\n<h2 id=\"Open-Files\"><a href=\"#Open-Files\" class=\"headerlink\" title=\"Open Files\"></a>Open Files</h2><h3 id=\"File-Descriptor\"><a href=\"#File-Descriptor\" class=\"headerlink\" title=\"File Descriptor\"></a><strong>File Descriptor</strong></h3><p>文件操作符，一个小的整数，标识打开的文件。</p>\n<blockquote>\n<p>文件操作符也是函数返回值，每次系统调用时都应该检查返回值</p>\n</blockquote>\n<h2 id=\"Close-Files\"><a href=\"#Close-Files\" class=\"headerlink\" title=\"Close Files\"></a>Close Files</h2><p>close(fd)</p>\n<blockquote>\n<p>关闭文件时也是可能出错的，多线程时共享内存的情况，所以也应该检查返回值</p>\n</blockquote>\n<h2 id=\"Reading-Files-amp-Writing-Files\"><a href=\"#Reading-Files-amp-Writing-Files\" class=\"headerlink\" title=\"Reading Files &amp; Writing Files\"></a>Reading Files &amp; Writing Files</h2><p>需要文件描述符fd和指向buffer的指针及其大小。</p>\n<blockquote>\n<p>Tips : strace 可以检查程序的系统级调用。<br>读写文件时，当字节数大于1小于最大值时，称作Short Counts,发生在以下三种情况</p>\n</blockquote>\n<ul>\n<li>遇到EOF</li>\n<li>在终端读入时遇到换行符</li>\n<li>读写networks sockets</li>\n</ul>\n<p>不会发生Short Counts的情况</p>\n<ul>\n<li>从disk读入</li>\n<li>向disk写入</li>\n</ul>\n<h2 id=\"RIO\"><a href=\"#RIO\" class=\"headerlink\" title=\"RIO\"></a>RIO</h2><p>RIO是健壮的I/O包，在Socket中非常有用。RIO提供了非缓存和缓存的两类函数。</p>\n<blockquote>\n<p>Buffered RIO are thread-safe</p>\n</blockquote>\n<h3 id=\"Unbuffered\"><a href=\"#Unbuffered\" class=\"headerlink\" title=\"Unbuffered\"></a>Unbuffered</h3><p>循环读入每一个字节，根据返回值进行讨论</p>\n<h3 id=\"Buffered\"><a href=\"#Buffered\" class=\"headerlink\" title=\"Buffered\"></a>Buffered</h3><p>先读入一段字节到缓冲区，通过指针访问读入字节，避免了重复调用系统的I/O函数，提高了效率。</p>\n<h2 id=\"Unix-Kernel-中的文件表示\"><a href=\"#Unix-Kernel-中的文件表示\" class=\"headerlink\" title=\"Unix Kernel 中的文件表示\"></a>Unix Kernel 中的文件表示</h2><p>//TODO</p>\n<h3 id=\"Fiel-Metadata-（文件元数据）\"><a href=\"#Fiel-Metadata-（文件元数据）\" class=\"headerlink\" title=\"Fiel Metadata （文件元数据）\"></a>Fiel Metadata （文件元数据）</h3><p>描述文件信息的数据，它们存放在结构体stat中。这些数据描述了文件是否可读，文件类型等基本信息。</p>\n<h3 id=\"sharing\"><a href=\"#sharing\" class=\"headerlink\" title=\"sharing\"></a>sharing</h3><h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><h2 id=\"Standard-I-O\"><a href=\"#Standard-I-O\" class=\"headerlink\" title=\"Standard I/O\"></a>Standard I/O</h2><p>Standard I/O 指的其实就是Ｃ语言中常见的I/O函数，如scanf,fscanf,printf,它们都是待缓冲的I/O。</p>\n<blockquote>\n<p>Standard I/O 常用于终端文件读写，而RIO常用于网络编程。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"System-Level-I-O\"><a href=\"#System-Level-I-O\" class=\"headerlink\" title=\"System Level I/O\"></a>System Level I/O</h1><h2 id=\"Unix-I-O\"><a href=\"#Unix-I-O\" class=\"headerlink\" title=\"Unix I/O\"></a>Unix I/O</h2><p>在Unix系统中，一切对象都是<strong>文件</strong>。而文件只是一组字节序列。甚至连接到系统的设备，Socket都视为文件。</p>\n<p>文件的分类</p>\n<ul>\n<li>Regular file: Contains arbitrary data</li>\n<li>Directory: Index for a related group of files</li>\n<li>Socket: For communicating with a process on another machine</li>\n<li>Named pipes(管道)</li>\n<li>Symbolic links</li>\n<li>Character and block decvices</li>\n</ul>\n<blockquote>\n<p>seek 指示文件读到的位置</p>\n</blockquote>\n<h3 id=\"Regula-files\"><a href=\"#Regula-files\" class=\"headerlink\" title=\"Regula files\"></a>Regula files</h3><blockquote>\n<p>C语言标准库中的API将常规文件分为text file, binary file。Linux/MAC 用’\\n’, ‘\\r\\n’</p>\n</blockquote>\n<h3 id=\"Directories\"><a href=\"#Directories\" class=\"headerlink\" title=\"Directories\"></a>Directories</h3><p>一组links组成了目录文件，每一个link是文件名到文件的映射。</p>\n<h2 id=\"Open-Files\"><a href=\"#Open-Files\" class=\"headerlink\" title=\"Open Files\"></a>Open Files</h2><h3 id=\"File-Descriptor\"><a href=\"#File-Descriptor\" class=\"headerlink\" title=\"File Descriptor\"></a><strong>File Descriptor</strong></h3><p>文件操作符，一个小的整数，标识打开的文件。</p>\n<blockquote>\n<p>文件操作符也是函数返回值，每次系统调用时都应该检查返回值</p>\n</blockquote>\n<h2 id=\"Close-Files\"><a href=\"#Close-Files\" class=\"headerlink\" title=\"Close Files\"></a>Close Files</h2><p>close(fd)</p>\n<blockquote>\n<p>关闭文件时也是可能出错的，多线程时共享内存的情况，所以也应该检查返回值</p>\n</blockquote>\n<h2 id=\"Reading-Files-amp-Writing-Files\"><a href=\"#Reading-Files-amp-Writing-Files\" class=\"headerlink\" title=\"Reading Files &amp; Writing Files\"></a>Reading Files &amp; Writing Files</h2><p>需要文件描述符fd和指向buffer的指针及其大小。</p>\n<blockquote>\n<p>Tips : strace 可以检查程序的系统级调用。<br>读写文件时，当字节数大于1小于最大值时，称作Short Counts,发生在以下三种情况</p>\n</blockquote>\n<ul>\n<li>遇到EOF</li>\n<li>在终端读入时遇到换行符</li>\n<li>读写networks sockets</li>\n</ul>\n<p>不会发生Short Counts的情况</p>\n<ul>\n<li>从disk读入</li>\n<li>向disk写入</li>\n</ul>\n<h2 id=\"RIO\"><a href=\"#RIO\" class=\"headerlink\" title=\"RIO\"></a>RIO</h2><p>RIO是健壮的I/O包，在Socket中非常有用。RIO提供了非缓存和缓存的两类函数。</p>\n<blockquote>\n<p>Buffered RIO are thread-safe</p>\n</blockquote>\n<h3 id=\"Unbuffered\"><a href=\"#Unbuffered\" class=\"headerlink\" title=\"Unbuffered\"></a>Unbuffered</h3><p>循环读入每一个字节，根据返回值进行讨论</p>\n<h3 id=\"Buffered\"><a href=\"#Buffered\" class=\"headerlink\" title=\"Buffered\"></a>Buffered</h3><p>先读入一段字节到缓冲区，通过指针访问读入字节，避免了重复调用系统的I/O函数，提高了效率。</p>\n<h2 id=\"Unix-Kernel-中的文件表示\"><a href=\"#Unix-Kernel-中的文件表示\" class=\"headerlink\" title=\"Unix Kernel 中的文件表示\"></a>Unix Kernel 中的文件表示</h2><p>//TODO</p>\n<h3 id=\"Fiel-Metadata-（文件元数据）\"><a href=\"#Fiel-Metadata-（文件元数据）\" class=\"headerlink\" title=\"Fiel Metadata （文件元数据）\"></a>Fiel Metadata （文件元数据）</h3><p>描述文件信息的数据，它们存放在结构体stat中。这些数据描述了文件是否可读，文件类型等基本信息。</p>\n<h3 id=\"sharing\"><a href=\"#sharing\" class=\"headerlink\" title=\"sharing\"></a>sharing</h3><h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><h2 id=\"Standard-I-O\"><a href=\"#Standard-I-O\" class=\"headerlink\" title=\"Standard I/O\"></a>Standard I/O</h2><p>Standard I/O 指的其实就是Ｃ语言中常见的I/O函数，如scanf,fscanf,printf,它们都是待缓冲的I/O。</p>\n<blockquote>\n<p>Standard I/O 常用于终端文件读写，而RIO常用于网络编程。</p>\n</blockquote>\n"},{"title":"deep learning part 1","date":"2021-08-09T07:39:11.000Z","_content":"","source":"_posts/deep-learning-part-1.md","raw":"---\ntitle: deep learning part 1\ndate: 2021-08-09 15:39:11\ntags:\n---\n","slug":"deep-learning-part-1","published":1,"updated":"2021-08-09T07:39:11.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdkes00066ykka0fd8n23","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"surprise","date":"2021-08-05T16:39:57.000Z","_content":"\n\n\nWelcome to my fiendish little bomb. You have 6 phases with\nwhich to blow yourself up. Have a nice day!\nBorder relations with Canada have never been better.\nPhase 1 defused. How about the next one?\n1 2 4 8 16 32\nThat's number 2.  Keep going!\n^CSo you think you can stop the bomb with ctrl-c, do you?\nWell...OK. :-)\n\n","source":"_posts/surprise.md","raw":"---\ntitle: surprise\ndate: 2021-08-06 00:39:57\ntags:\n---\n\n\n\nWelcome to my fiendish little bomb. You have 6 phases with\nwhich to blow yourself up. Have a nice day!\nBorder relations with Canada have never been better.\nPhase 1 defused. How about the next one?\n1 2 4 8 16 32\nThat's number 2.  Keep going!\n^CSo you think you can stop the bomb with ctrl-c, do you?\nWell...OK. :-)\n\n","slug":"surprise","published":1,"updated":"2021-08-05T16:40:28.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksjzdkes00076ykk2enqfjjw","content":"<p>Welcome to my fiendish little bomb. You have 6 phases with<br>which to blow yourself up. Have a nice day!<br>Border relations with Canada have never been better.<br>Phase 1 defused. How about the next one?<br>1 2 4 8 16 32<br>That’s number 2.  Keep going!<br>^CSo you think you can stop the bomb with ctrl-c, do you?<br>Well…OK. :-)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to my fiendish little bomb. You have 6 phases with<br>which to blow yourself up. Have a nice day!<br>Border relations with Canada have never been better.<br>Phase 1 defused. How about the next one?<br>1 2 4 8 16 32<br>That’s number 2.  Keep going!<br>^CSo you think you can stop the bomb with ctrl-c, do you?<br>Well…OK. :-)</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}